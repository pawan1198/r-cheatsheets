% Options for packages loaded elsewhere
% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames,x11names}{xcolor}
%
\documentclass[
  letterpaper,
  DIV=11,
  numbers=noendperiod]{scrreprt}
\usepackage{xcolor}
\usepackage{amsmath,amssymb}
\setcounter{secnumdepth}{5}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math} % this also loads fontspec
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else
  % xetex/luatex font selection
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
% Make \paragraph and \subparagraph free-standing
\makeatletter
\ifx\paragraph\undefined\else
  \let\oldparagraph\paragraph
  \renewcommand{\paragraph}{
    \@ifstar
      \xxxParagraphStar
      \xxxParagraphNoStar
  }
  \newcommand{\xxxParagraphStar}[1]{\oldparagraph*{#1}\mbox{}}
  \newcommand{\xxxParagraphNoStar}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
  \let\oldsubparagraph\subparagraph
  \renewcommand{\subparagraph}{
    \@ifstar
      \xxxSubParagraphStar
      \xxxSubParagraphNoStar
  }
  \newcommand{\xxxSubParagraphStar}[1]{\oldsubparagraph*{#1}\mbox{}}
  \newcommand{\xxxSubParagraphNoStar}[1]{\oldsubparagraph{#1}\mbox{}}
\fi
\makeatother

\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{241,243,245}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.40,0.45,0.13}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\BuiltInTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\ExtensionTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.28,0.35,0.67}{#1}}
\newcommand{\ImportTok}[1]{\textcolor[rgb]{0.00,0.46,0.62}{#1}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.07,0.07,0.07}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}

\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\newsavebox\pandoc@box
\newcommand*\pandocbounded[1]{% scales image to fit in text height/width
  \sbox\pandoc@box{#1}%
  \Gscale@div\@tempa{\textheight}{\dimexpr\ht\pandoc@box+\dp\pandoc@box\relax}%
  \Gscale@div\@tempb{\linewidth}{\wd\pandoc@box}%
  \ifdim\@tempb\p@<\@tempa\p@\let\@tempa\@tempb\fi% select the smaller of both
  \ifdim\@tempa\p@<\p@\scalebox{\@tempa}{\usebox\pandoc@box}%
  \else\usebox{\pandoc@box}%
  \fi%
}
% Set default figure placement to htbp
\def\fps@figure{htbp}
\makeatother





\setlength{\emergencystretch}{3em} % prevent overfull lines

\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}



 


\KOMAoption{captions}{tableheading}
\makeatletter
\@ifpackageloaded{tcolorbox}{}{\usepackage[skins,breakable]{tcolorbox}}
\@ifpackageloaded{fontawesome5}{}{\usepackage{fontawesome5}}
\definecolor{quarto-callout-color}{HTML}{909090}
\definecolor{quarto-callout-note-color}{HTML}{0758E5}
\definecolor{quarto-callout-important-color}{HTML}{CC1914}
\definecolor{quarto-callout-warning-color}{HTML}{EB9113}
\definecolor{quarto-callout-tip-color}{HTML}{00A047}
\definecolor{quarto-callout-caution-color}{HTML}{FC5300}
\definecolor{quarto-callout-color-frame}{HTML}{acacac}
\definecolor{quarto-callout-note-color-frame}{HTML}{4582ec}
\definecolor{quarto-callout-important-color-frame}{HTML}{d9534f}
\definecolor{quarto-callout-warning-color-frame}{HTML}{f0ad4e}
\definecolor{quarto-callout-tip-color-frame}{HTML}{02b875}
\definecolor{quarto-callout-caution-color-frame}{HTML}{fd7e14}
\makeatother
\makeatletter
\@ifpackageloaded{bookmark}{}{\usepackage{bookmark}}
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\AtBeginDocument{%
\ifdefined\contentsname
  \renewcommand*\contentsname{Table of contents}
\else
  \newcommand\contentsname{Table of contents}
\fi
\ifdefined\listfigurename
  \renewcommand*\listfigurename{List of Figures}
\else
  \newcommand\listfigurename{List of Figures}
\fi
\ifdefined\listtablename
  \renewcommand*\listtablename{List of Tables}
\else
  \newcommand\listtablename{List of Tables}
\fi
\ifdefined\figurename
  \renewcommand*\figurename{Figure}
\else
  \newcommand\figurename{Figure}
\fi
\ifdefined\tablename
  \renewcommand*\tablename{Table}
\else
  \newcommand\tablename{Table}
\fi
}
\@ifpackageloaded{float}{}{\usepackage{float}}
\floatstyle{ruled}
\@ifundefined{c@chapter}{\newfloat{codelisting}{h}{lop}}{\newfloat{codelisting}{h}{lop}[chapter]}
\floatname{codelisting}{Listing}
\newcommand*\listoflistings{\listof{codelisting}{List of Listings}}
\usepackage{amsthm}
\theoremstyle{remark}
\AtBeginDocument{\renewcommand*{\proofname}{Proof}}
\newtheorem*{remark}{Remark}
\newtheorem*{solution}{Solution}
\newtheorem{refremark}{Remark}[chapter]
\newtheorem{refsolution}{Solution}[chapter]
\makeatother
\makeatletter
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\@ifpackageloaded{subcaption}{}{\usepackage{subcaption}}
\makeatother
\usepackage{bookmark}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same}
\hypersetup{
  pdftitle={R Cheatsheets},
  pdfauthor={Pawan},
  colorlinks=true,
  linkcolor={blue},
  filecolor={Maroon},
  citecolor={Blue},
  urlcolor={Blue},
  pdfcreator={LaTeX via pandoc}}


\title{R Cheatsheets}
\author{Pawan}
\date{2022-11-09}
\begin{document}
\maketitle

\renewcommand*\contentsname{Table of contents}
{
\hypersetup{linkcolor=}
\setcounter{tocdepth}{2}
\tableofcontents
}

\bookmarksetup{startatroot}

\chapter*{Preface}\label{preface}
\addcontentsline{toc}{chapter}{Preface}

\markboth{Preface}{Preface}

\href{https://www.r-project.org/about.html}{}

\bookmarksetup{startatroot}

\chapter*{Author}\label{author}
\addcontentsline{toc}{chapter}{Author}

\markboth{Author}{Author}

\href{author.md}{Pawan}

\bookmarksetup{startatroot}

\chapter*{Getting Started with R Cheat
Sheet}\label{getting-started-with-r-cheat-sheet}
\addcontentsline{toc}{chapter}{Getting Started with R Cheat Sheet}

\markboth{Getting Started with R Cheat Sheet}{Getting Started with R
Cheat Sheet}

R is one of the most popular programming languages in data science and
is widely used across various industries and academia. It's open-source,
easy to learn, and capable of handling complex data and statistical
manipulations, making it the preferred computing environment for many
data scientists today.

This cheat sheet will cover an overview of getting started with R.

You can find some useful cheatsheets \href{cheatsheets.md}{here}

\bookmarksetup{startatroot}

\chapter*{The Advantages of R for Statistical
Analysis}\label{the-advantages-of-r-for-statistical-analysis}
\addcontentsline{toc}{chapter}{The Advantages of R for Statistical
Analysis}

\markboth{The Advantages of R for Statistical Analysis}{The Advantages
of R for Statistical Analysis}

R has emerged as one of the most powerful and versatile programming
languages in data analysis and statistical computing. It's Developed by
statisticians for statisticians, R is specifically designed to handle
complex data analysis tasks, making it an ideal choice for researchers,
data scientists, and analysts across various fields. This essay explores
the numerous advantages of R for statistical analysis, including its
extensive libraries, community support, data visualization capabilities,
and flexibility.

\bookmarksetup{startatroot}

\chapter*{1. Comprehensive Statistical
Libraries}\label{comprehensive-statistical-libraries}
\addcontentsline{toc}{chapter}{1. Comprehensive Statistical Libraries}

\markboth{1. Comprehensive Statistical Libraries}{1. Comprehensive
Statistical Libraries}

One of the most significant advantages of R is its collection of
packages and libraries tailored for statistical analysis. The
Comprehensive R Archive Network (CRAN) hosts thousands of packages that
cover a wide range of statistical techniques, from basic descriptive
statistics to advanced machine learning algorithms.\\
For instance, packages like data.table, dplyr and tidyr facilitate data
manipulation and cleaning, while ggplot2 provides powerful tools for
data visualization. More specialized packages, such as base-R for mixed
and various statistical in-builts functions and survival for survival
analysis, enable users to conduct sophisticated analyses with relative
ease. The availability of these packages means that R can be used for
virtually any statistical task, making it a one-stop solution for data
analysis.

\bookmarksetup{startatroot}

\chapter*{2. Strong Community Support}\label{strong-community-support}
\addcontentsline{toc}{chapter}{2. Strong Community Support}

\markboth{2. Strong Community Support}{2. Strong Community Support}

R boasts a vibrant and active community of users and developers who
contribute to its growth and evolution. This community support is
invaluable for both novice and experienced users. Online forums, such as
Stack Overflow and R-bloggers, statictiaclglobe provide platforms for
users to ask questions, share insights, and collaborate on projects.
Additionally, the R community regularly organizes conferences,
workshops, and meetups, fostering an environment of continuous learning
and knowledge sharing. The collaborative nature of the R community also
means that users can access a wealth of resources, including tutorials,
documentation, and example datasets. This support network is
particularly beneficial for those new to statistical analysis, as it
allows them to learn from others' experiences and quickly overcome
challenges.

\bookmarksetup{startatroot}

\chapter*{3. Data Visualization
Capabilities}\label{data-visualization-capabilities}
\addcontentsline{toc}{chapter}{3. Data Visualization Capabilities}

\markboth{3. Data Visualization Capabilities}{3. Data Visualization
Capabilities}

Effective data visualization is a crucial aspect of statistical
analysis, as it helps to communicate findings clearly and intuitively. R
in this area, offering a range of powerful visualization tools that
enable users to create high-quality graphics. The~ggplot2~package, in
particular, has gained widespread acclaim for its ability to produce
complex and aesthetically pleasing visualizations with minimal code.
With~ggplot2, users can create a variety of plots, including scatter
plots, line graphs, histograms, and box plots, all while maintaining
control over the aesthetics and layout. The grammar of the graphics
approach used by~ggplot2~allows for layering of visual elements, making
it easy to add annotations, customize scales, and combine multiple plots
into a single visualization. This flexibility ensures that users can
effectively convey their analytical results, making R an excellent
choice for presenting data-driven insights.

\bookmarksetup{startatroot}

\chapter*{4. Flexibility and
Extensibility}\label{flexibility-and-extensibility}
\addcontentsline{toc}{chapter}{4. Flexibility and Extensibility}

\markboth{4. Flexibility and Extensibility}{4. Flexibility and
Extensibility}

R is an open-source language, which means that users have the freedom to
modify and extend its capabilities. This flexibility is particularly
advantageous for researchers and analysts who may need to implement
custom statistical methods or algorithms. Users can write their
functions or modify existing ones to suit their specific needs, allowing
for a high degree of customization in their analyses. Moreover, R can
easily integrate with other programming languages, such as Python and
C++, enabling users to leverage the strengths of multiple languages in
their projects. This interoperability allows for the incorporation of R
into larger data processing pipelines, making it a versatile tool in a
data scientist's toolkit.

\bookmarksetup{startatroot}

\chapter*{5. Reproducibility and
Documentation}\label{reproducibility-and-documentation}
\addcontentsline{toc}{chapter}{5. Reproducibility and Documentation}

\markboth{5. Reproducibility and Documentation}{5. Reproducibility and
Documentation}

Reproducibility is a cornerstone of scientific research, and R provides
several tools to ensure that analyses can be easily replicated. The use
of R Markdown allows users to create dynamic documents that combine
code, output, and narrative text in a single file. This feature not only
enhances the clarity of the analysis but also facilitates the sharing of
results with others. R Markdown documents can be rendered in various
formats, including HTML, PDF, and Word, making it easy to present
findings professionally. Additionally, the integration of code and
documentation ensures that analyses are transparent and reproducible,
which is essential for building trust in research findings.

\bookmarksetup{startatroot}

\chapter*{6. Statistical Modeling and Machine
Learning}\label{statistical-modeling-and-machine-learning}
\addcontentsline{toc}{chapter}{6. Statistical Modeling and Machine
Learning}

\markboth{6. Statistical Modeling and Machine Learning}{6. Statistical
Modeling and Machine Learning}

R is particularly well-suited for statistical modeling and machine
learning applications. The language provides a rich set of tools for
fitting various statistical models, including linear regression,
generalized linear models, and time series analysis. The~caret~package,
for example, offers a unified interface for training and evaluating
machine learning models, making it easier for users to experiment with
different algorithms and tuning parameters. Furthermore, R's ability to
handle large datasets and perform complex calculations efficiently makes
it a strong contender for big data applications. With the advent of
packages like~data.table~and~dplyr, R can process large volumes of data
quickly, allowing analysts to derive insights from big data without
sacrificing performance.

\bookmarksetup{startatroot}

\chapter*{7. Integration with Other
Tools}\label{integration-with-other-tools}
\addcontentsline{toc}{chapter}{7. Integration with Other Tools}

\markboth{7. Integration with Other Tools}{7. Integration with Other
Tools}

R's versatility extends to its ability to integrate seamlessly with
various data sources and tools. It can connect to databases such as
MySQL, PostgreSQL, and SQLite, enabling users to perform analyses
directly on data stored in relational databases. Additionally, R can
read and write data in multiple formats, including CSV, Excel, and JSON,
making it easy to import and export data as needed. Moreover, R can be
integrated with web applications and dashboards through packages
like~Shiny, which allows users to create interactive web applications
for data visualization and analysis. This capability is particularly
useful for sharing insights with stakeholders who may not have a
technical background, as it enables them to explore data and results
intuitively.

\bookmarksetup{startatroot}

\chapter*{8. Educational Resources and Learning
Curve}\label{educational-resources-and-learning-curve}
\addcontentsline{toc}{chapter}{8. Educational Resources and Learning
Curve}

\markboth{8. Educational Resources and Learning Curve}{8. Educational
Resources and Learning Curve}

For those new to statistical analysis, R offers a wealth of educational
resources that can help users get up to speed quickly. Numerous online
courses, tutorials, and textbooks are available, catering to different
learning styles and levels of expertise. The availability of these
resources makes it easier for individuals to learn R and apply it to
their statistical analyses. While R has a reputation for having a
steeper learning curve compared to some other programming languages, its
syntax is logical and consistent, which can facilitate the learning
process. Once users become familiar with the basics, they often find
that R's capabilities and flexibility far outweigh the initial
challenges.

\bookmarksetup{startatroot}

\chapter*{9. Industry Adoption and Job Market
Demand}\label{industry-adoption-and-job-market-demand}
\addcontentsline{toc}{chapter}{9. Industry Adoption and Job Market
Demand}

\markboth{9. Industry Adoption and Job Market Demand}{9. Industry
Adoption and Job Market Demand}

R has gained significant traction in various industries, particularly in
fields such as finance, healthcare, and academia. Many organizations
recognize the value of R for data analysis and statistical modeling,
leading to an increasing demand for professionals skilled in R. This
trend is reflected in job postings that frequently list R as a required
or preferred skill for data analyst and data scientist positions. As
more companies adopt data-driven decision-making practices, proficiency
in R can enhance career prospects and open doors to new opportunities.
The language's strong reputation in the statistical community further
solidifies its position as a valuable asset for anyone looking to
advance their career in data analysis.

\bookmarksetup{startatroot}

\chapter*{10. Conclusion}\label{conclusion}
\addcontentsline{toc}{chapter}{10. Conclusion}

\markboth{10. Conclusion}{10. Conclusion}

In conclusion, R stands out as a powerful and flexible tool for
statistical analysis, offering a wide range of advantages that cater to
the needs of researchers, analysts, and data scientists. Its
comprehensive libraries, strong community support, exceptional data
visualization capabilities, and flexibility make it an ideal choice for
tackling complex data analysis tasks. Furthermore, R's emphasis on
reproducibility and documentation ensures that analyses are transparent
and trustworthy. As the demand for data analysis continues to grow
across various industries, R's relevance and utility are likely to
persist. By leveraging R's capabilities, users can unlock valuable
insights from their data, ultimately driving informed decision-making
and contributing to advancements in their respective fields. Whether you
are a seasoned statistician or a newcomer to data analysis, R provides
the tools and resources necessary to succeed in the ever-evolving
landscape of data science.

\bookmarksetup{startatroot}

\chapter{Getting Started with R Cheat
Sheet}\label{getting-started-with-r-cheat-sheet-1}

R is one of the most popular programming languages in data science and
is widely used across various industries and academia. It's open-source,
easy to learn, and capable of handling complex data and statistical
manipulations, making it the preferred computing environment for many
data scientists today.

This cheat sheet will cover an overview of getting started with R.

\bookmarksetup{startatroot}

\chapter{Using Packages in R}\label{using-packages-in-r}

R packages are collections of functions and tools developed by the R
community. They increase the power of R by improving existing base R
functionalities or adding new ones.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Lets you install new packages (e.g., tidyverse package)}
\FunctionTok{install.packages}\NormalTok{(}\StringTok{"tidyverse"}\NormalTok{)}

\DocumentationTok{\#\#Lets you load and use packages (e.g., tidyverse package)}
\FunctionTok{library}\NormalTok{(tidyverse)}
\end{Highlighting}
\end{Shaded}

\bookmarksetup{startatroot}

\chapter{The Working Directory}\label{the-working-directory}

The working directory is a file path that R will use as the starting
point for relative file paths. That is, it's the default location for
importing and exporting files. An example of a working directory looks
like ``/file/path''

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\#Returns your current working directory}
\FunctionTok{getwd}\NormalTok{()}

\DocumentationTok{\#\#Changes your current working directory to a desired file path}
\FunctionTok{setwd}\NormalTok{(}\StringTok{"/file/path"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\bookmarksetup{startatroot}

\chapter{Operators in R}\label{operators-in-r}

\section{Arithmetic Operators in R}\label{arithmetic-operators-in-r}

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Operator & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
a + b & Sums two variables \\
a - b & Subtracts two variables \\
a * b & Multiply two variables \\
a / b & Divide two variables \\
a \^{} b & Exponentiation of a variable \\
a \%\% b & The remainder of a variable \\
a \%/\% b & Integer division of variables \\
\end{longtable}

\section{Relational Operators in R}\label{relational-operators-in-r}

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Operator & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
a == b & Tests for equality \\
a != b & Tests for inequality \\
a \textgreater{} b & Tests for greater than \\
a \textless{} b & Tests for smaller than \\
a \textgreater= b & Tests for greater or equal than \\
a \textless= b & Tests for smaller or equal than \\
\end{longtable}

\section{Logical Operators in R}\label{logical-operators-in-r}

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Operator & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
! & Logical NOT \\
\& & Element-wise Logical AND \\
\&\& & Logical AND \\
\textbar{} & Element-wise Logical OR \\
\textbar\textbar{} & Logical OR \\
\end{longtable}

\section{Assignment Operators in R}\label{assignment-operators-in-r}

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Operator & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
x \textless- 1, x = 1 & Assigns a variable to x \\
\end{longtable}

\section{Other Operators in R}\label{other-operators-in-r}

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Operator & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\%in\% & Identifies whether an element belongs to a vector \\
\$ & Allows you to access objects stored within an object \\
\%\textgreater\% & Part of magrittr package, it's used to pass objects
to functions \\
\end{longtable}

\bookmarksetup{startatroot}

\chapter{Getting Started with Vectors in
R}\label{getting-started-with-vectors-in-r}

Vectors are one-dimensional arrays that can hold numeric data, character
data, or logical data. In other words, a vector is a simple tool to
store data.\\
A vector is a contiguous collection of objects of the same type. Common
types of vectors include logical, integer, double, and character.

\section{Creating Vectors in R}\label{creating-vectors-in-r}

A vector is a one-dimensional data set or a single-column data set, that
doesn't have a row

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{59}\NormalTok{)}
\DocumentationTok{\#\# output}
\NormalTok{[}\DecValTok{1}\NormalTok{]  }\DecValTok{1}  \DecValTok{2}  \DecValTok{3}  \DecValTok{4}  \DecValTok{5}  \DecValTok{6}  \DecValTok{7}  \DecValTok{8}  \DecValTok{9} \DecValTok{10} \DecValTok{11} \DecValTok{12} \DecValTok{13} \DecValTok{14} \DecValTok{15} \DecValTok{16} \DecValTok{17} \DecValTok{18} \DecValTok{19} \DecValTok{20} \DecValTok{21} \DecValTok{22} \DecValTok{23} \DecValTok{24} \DecValTok{25} \DecValTok{26} \DecValTok{27} \DecValTok{28} \DecValTok{29} \DecValTok{30} \DecValTok{31} \DecValTok{32} \DecValTok{33} \DecValTok{34} \DecValTok{35} \DecValTok{36} \DecValTok{37} \DecValTok{38}
\NormalTok{[}\DecValTok{39}\NormalTok{] }\DecValTok{39} \DecValTok{40} \DecValTok{41} \DecValTok{42} \DecValTok{43} \DecValTok{44} \DecValTok{45} \DecValTok{46} \DecValTok{47} \DecValTok{48} \DecValTok{49} \DecValTok{50} \DecValTok{51} \DecValTok{52} \DecValTok{53} \DecValTok{54} \DecValTok{55} \DecValTok{56} \DecValTok{57} \DecValTok{58} \DecValTok{59}
  
\end{Highlighting}
\end{Shaded}

Here c called the command\\
Within the brackets, the things called elements, and in the starting of
elements inside the square bracket {[}{]} is the position of the element
or the indicate the row number

There are types of vector\\
Numeric vector - 1,2,3,4\\
Character vector - ``A'', ``a'', ``b'', ``ram''\\
Logical - True, False

\begin{itemize}
\tightlist
\item
  Creates a vector using elements separated by commas
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{5}\NormalTok{)}
\DocumentationTok{\#\#Output}
\SpecialCharTok{$}\ErrorTok{\textgreater{}} \DecValTok{1} \DecValTok{3} \DecValTok{5}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Creates a vector of integers between two numbers
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1}\SpecialCharTok{:}\DecValTok{7}
\DocumentationTok{\#\#Output}
\SpecialCharTok{$} \DecValTok{1} \DecValTok{2} \DecValTok{3} \DecValTok{4} \DecValTok{5} \DecValTok{6} \DecValTok{7}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Creates a vector between two numbers, with a specified interval
  between each element
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{seq}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{8}\NormalTok{,}\AttributeTok{by =} \DecValTok{2}\NormalTok{)}
\DocumentationTok{\#\#Output}
\SpecialCharTok{$} \DecValTok{2} \DecValTok{4} \DecValTok{6} \DecValTok{8}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Creates a vector of given elements repeated a number of times
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rep}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{8}\NormalTok{,}\AttributeTok{times =} \DecValTok{4}\NormalTok{)}
\DocumentationTok{\#\#Output}
\SpecialCharTok{$} \DecValTok{2} \DecValTok{8} \DecValTok{2} \DecValTok{8} \DecValTok{2} \DecValTok{8} \DecValTok{2} \DecValTok{8}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Creates a vector of given elements repeating each element a number of
  times
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rep}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{8}\NormalTok{,}\AttributeTok{each =} \DecValTok{3}\NormalTok{)}
\DocumentationTok{\#\#Output}
\SpecialCharTok{$} \DecValTok{2} \DecValTok{2} \DecValTok{2} \DecValTok{8} \DecValTok{8} \DecValTok{8} 
\end{Highlighting}
\end{Shaded}

\section{Vector Functions in R}\label{vector-functions-in-r}

\begin{itemize}
\tightlist
\item
  \texttt{sort(my\_vector)} : Returns my\_vector sorted
\item
  \texttt{rev(my\_vector)} : Reverses the order of my\_vector
\item
  \texttt{table(my\_vector)} : Count the values in a vector
\item
  \texttt{unique(my\_vector)} : Distinct elements in a vector
\end{itemize}

\section{Selecting Vector Elements in
R}\label{selecting-vector-elements-in-r}

\begin{itemize}
\tightlist
\item
  \texttt{my\_vector{[}6{]}} : Returns the sixth element of my\_vector
\item
  \texttt{my\_vector{[}-6{]}} : Returns all but the sixth element
\item
  \texttt{my\_vector{[}2:6{]}} : Returns elements two to six
\item
  \texttt{my\_vector{[}-(2:6){]}} : Returns all elements except those
  between the second and the sixth
\item
  \texttt{my\_vector{[}c(2,6){]}} : Returns the second and sixth
  elements
\item
  \texttt{my\_vector{[}x\ ==\ 5{]}} : Returns elements equal to 5
\item
  \texttt{my\_vector{[}x\ \textless{}\ 5\ {]}} : Returns elements less
  than 5
\item
  \texttt{my\_vector{[}x\ \%in\%\ c(2,\ 5\ ,8\ ){]}} : Returns elements
  in the set \{2, 5, 8\}
\end{itemize}

\bookmarksetup{startatroot}

\chapter{Math Functions in R}\label{math-functions-in-r}

\begin{itemize}
\tightlist
\item
  \texttt{log(x)} : Returns the logarithm of a variable
\item
  \texttt{exp(x)} : Returns exponential of a variable
\item
  \texttt{max(x)} : Returns the maximum value of a vector
\item
  \texttt{min(x)} : Returns the minimum value of a vector
\item
  \texttt{mean(x)} : Returns the mean of a vector
\item
  \texttt{sum(x)} : Returns the sum of a vector
\item
  \texttt{median(x)} : Returns the median of a vector
\item
  \texttt{quantile(x)} : Percentage quantiles of a vector
\item
  \texttt{round(x,\ n)} : Round to n decimal places
\item
  \texttt{rank(x)} : Rank of elements in a vector
\item
  \texttt{signif(x,\ n)} : Round off n significant figures
\item
  \texttt{var(x)} : Variance of a vector
\item
  \texttt{cor(x,\ y)} : Correlation between two vectors
\item
  \texttt{sd(x)} : Standard deviation of a vector
\end{itemize}

\bookmarksetup{startatroot}

\chapter{Getting Started with Strings in
R}\label{getting-started-with-strings-in-r}

The \texttt{stringr} package makes it easier to work with strings in R -
you should install and load this package to use the following functions.

\section{Find matches}\label{find-matches}

\begin{itemize}
\tightlist
\item
  Detects the presence of a pattern match in a string\\
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str\_detect}\NormalTok{(string, pattern, }\AttributeTok{negate =} \ConstantTok{FALSE}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Detects the presence of a pattern match at the beginning of a string\\
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str\_starts}\NormalTok{(string, pattern, }\AttributeTok{negate =} \ConstantTok{FALSE}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Finds the index of strings that contain pattern match\\
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str\_which}\NormalTok{(string, pattern, }\AttributeTok{negate =} \ConstantTok{FALSE}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Locates the positions of pattern matches in a string\\
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str\_locate}\NormalTok{(string, pattern)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Counts the number of pattern matches in a string\\
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str\_count}\NormalTok{(string, pattern)}
\end{Highlighting}
\end{Shaded}

\section{Subset}\label{subset}

\begin{itemize}
\tightlist
\item
  Extracts substrings from a character vector\\
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str\_sub}\NormalTok{(string, }\AttributeTok{start =} \DecValTok{1}\NormalTok{L, }\AttributeTok{end =} \SpecialCharTok{{-}}\DecValTok{1}\NormalTok{L)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Returns strings that contain a pattern match\\
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str\_subset}\NormalTok{(string, pattern, }\AttributeTok{negate =} \ConstantTok{FALSE}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Returns the first pattern match in each string as a vector\\
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str\_extract}\NormalTok{(string, pattern) }
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Returns the first pattern match in each string as a matrix with a
  column for each group in the pattern\\
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str\_match}\NormalTok{(string, pattern)}
\end{Highlighting}
\end{Shaded}

\section{Mutate}\label{mutate}

\begin{itemize}
\tightlist
\item
  Replaces substrings by identifying the substrings with str\_sub() and
  assigning them to the results\\
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str\_sub}\NormalTok{() }\OtherTok{\textless{}{-}}\NormalTok{ value }
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Replaces the first matched pattern in each string\\
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str\_replace}\NormalTok{(string, pattern, replacement)  }
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Replaces all matched patterns in each string\\
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str\_replace\_all}\NormalTok{(string, pattern, replacement) }
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Converts strings to lowercase\\
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str\_to\_lower}\NormalTok{(string) }
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Converts strings to uppercase\\
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str\_to\_upper}\NormalTok{(string) }
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Converts strings to title case\\
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str\_to\_title}\NormalTok{(string) }
\end{Highlighting}
\end{Shaded}

\section{Join and split}\label{join-and-split}

\begin{itemize}
\tightlist
\item
  Repeats strings n times\\
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str\_dup}\NormalTok{(string, n)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Splits a vector of strings into a matrix of substrings\\
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str\_split\_fixed}\NormalTok{(string, pattern, n) }
\end{Highlighting}
\end{Shaded}

\bookmarksetup{startatroot}

\chapter{Getting Started with Data Frames in
R}\label{getting-started-with-data-frames-in-r}

A data frame has the variables of a data set as columns and the
observations as rows. + This creates the data frame df, seen below

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{x =} \DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{, }\AttributeTok{y =} \FunctionTok{c}\NormalTok{(}\StringTok{"h"}\NormalTok{, }\StringTok{"i"}\NormalTok{, }\StringTok{"j"}\NormalTok{), }\AttributeTok{z =} \DecValTok{12}\SpecialCharTok{:}\DecValTok{14}\NormalTok{)}
\CommentTok{\#\textgreater{}x y   z}
\CommentTok{\#\textgreater{}1 h 12}
\CommentTok{\#\textgreater{}2 i 13}
\CommentTok{\#\textgreater{}3 j 14}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  This selects all columns of the third row\\
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df[ ,}\DecValTok{3}\NormalTok{]}
\CommentTok{\#\textgreater{} x y z}
\CommentTok{\#\textgreater{} 3 j 14}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  This selects the column z\\
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df}\SpecialCharTok{$}\NormalTok{z}
\CommentTok{\#\textgreater{}z}
\CommentTok{\#\textgreater{}12 }
\CommentTok{\#\textgreater{}13}
\CommentTok{\#\textgreater{}14}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  This selects all rows of the second column\\
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df[ ,}\DecValTok{2}\NormalTok{]}
\CommentTok{\#\textgreater{}y}
\CommentTok{\#\textgreater{}h}
\CommentTok{\#\textgreater{}i}
\CommentTok{\#\textgreater{}j}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  This selects the third column of the second row\\
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df[}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{]  }

\CommentTok{\#\textgreater{}13}
\end{Highlighting}
\end{Shaded}

\bookmarksetup{startatroot}

\chapter{Manipulating Data Frames in
R}\label{manipulating-data-frames-in-r}

\begin{itemize}
\tightlist
\item
  Takes a sequence of vector, matrix, or data-frame arguments and
  combines them with columns\\
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cbind}\NormalTok{(df1,df2)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Takes a sequence of vector, matrix, or data frame arguments and
  combines them with rows\\
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rbind}\NormalTok{(df1,df2)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Extracts rows that meet logical criteria\\
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{filter}\NormalTok{(df, x }\SpecialCharTok{==} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Removes rows with duplicate values\\
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{distinct}\NormalTok{(df, z)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Selects rows by position\\
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{slice}\NormalTok{(df, }\DecValTok{10}\SpecialCharTok{:}\DecValTok{15}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Selects rows with the highest values\\
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{slice\_max}\NormalTok{(df, z, }\AttributeTok{prop =}  \FloatTok{0.25}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Extracts column values as a vector, by name or index\\
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{pull}\NormalTok{(df, y)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Extracts columns as a table\\
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{select}\NormalTok{(df, x, y)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Moves columns to a new position\\
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{relocate}\NormalTok{(df, x, }\AttributeTok{.after =} \FunctionTok{last\_col}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Renames columns\\
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rename}\NormalTok{(df,}\StringTok{"age"}\OtherTok{=}\NormalTok{z)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Orders rows by values of a column from high to low\\
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{arrange}\NormalTok{(df, }\FunctionTok{desc}\NormalTok{(x))}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Computes table of summaries\\
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{summarise}\NormalTok{(df, }\AttributeTok{total =} \FunctionTok{sum}\NormalTok{(x))}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Computes table of summaries\\
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{summarise}\NormalTok{(df, }\AttributeTok{total =} \FunctionTok{sum}\NormalTok{(x))}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Use group\_by() to create a ``grouped'' copy of a table grouped by
  columns (similarly to a pivot table in spreadsheets). dplyr functions
  will then manipulate each ``group'' separately and combine the results
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df }\SpecialCharTok{\%\textgreater{}\%}   
    \FunctionTok{group\_by}\NormalTok{(z) }\SpecialCharTok{\%\textgreater{}\%}   
    \FunctionTok{summarise}\NormalTok{(}\AttributeTok{total =} \FunctionTok{sum}\NormalTok{(x))  }
\NormalTok{summarise  }
\end{Highlighting}
\end{Shaded}

\href{episodes/00-intro-eported.pdf}{Next}

\bookmarksetup{startatroot}

\chapter{Introduction to R}\label{introduction-to-r}

\begin{itemize}
\tightlist
\item
  The main goal is to introduce users to the various objects in R, from
  atomic types to creating your own objects.
\item
  While this epsiode is foundational, be careful not to get caught in
  the weeds as the variety of types and operations can be overwhelming
  for new users, especially before they understand how this fits into
  their own ``workflow.''
\end{itemize}

\begin{itemize}
\tightlist
\item
  Define the following terms as they relate to R: object, assign, call,
  function, arguments, options.
\item
  Assign values to names in R.
\item
  Learn how to name objects.
\item
  Use comments to inform script.
\item
  Solve simple arithmetic operations in R.
\item
  Call functions and use arguments to change their default options.
\item
  Inspect the content of vectors and manipulate their content.
\item
  Subset values from vectors.
\item
  Analyze vectors with missing data.
\end{itemize}

\begin{itemize}
\tightlist
\item
  What data types are available in R?
\item
  What is an object?
\item
  How can objects of different data types be assigned to names?
\item
  What arithmetic and logical operators can be used?
\item
  How can subsets be extracted from vectors?
\item
  How does R treat missing values?
\item
  How can we deal with missing values in R?
\end{itemize}

\section{Creating objects in R}\label{creating-objects-in-r}

You can get output from R simply by typing math in the console:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{3} \SpecialCharTok{+} \DecValTok{5}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 8
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{12} \SpecialCharTok{/} \DecValTok{7}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 1.714286
\end{verbatim}

Everything that exists in \texttt{R} is an objects: from simple
numerical values, to strings, to more complex objects like vectors,
matrices, and lists. Even expressions and functions are objects in
\texttt{R}.

However, to do useful and interesting things, we need to name objects.
To do so, we need to give a \emph{name} followed by the assignment
operator \texttt{\textless{}-}, and the \emph{object} we want to be
named:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{area\_hectares }\OtherTok{\textless{}{-}} \FloatTok{1.0}
\end{Highlighting}
\end{Shaded}

\texttt{\textless{}-} is the assignment operator. It assigns values
(objects) on the right to names (also called \emph{symbols}) on the
left. So, after executing \texttt{x\ \textless{}-\ 3}, the value of
\texttt{x} is \texttt{3}. The arrow can be read as 3 \textbf{goes into}
\texttt{x}. For historical reasons, you can also use \texttt{=} for
assignments, but not in every context. Because of the
\href{https://blog.revolutionanalytics.com/2008/12/use-equals-or-arrow-for-assignment.html}{slight
differences} in syntax, it is good practice to always use
\texttt{\textless{}-} for assignments. More generally we prefer the
\texttt{\textless{}-} syntax over \texttt{=} because it makes it clear
what direction the assignment is operating (left assignment), and it
increases the read-ability of the code.

In RStudio, typing Alt + - (push Alt at the same time as the - key) will
write \texttt{\textless{}-} in a single keystroke in a PC, while typing
Option + - (push Option at the same time as the - key) does the same in
a Mac.

Objects can be given any name such as \texttt{x},
\texttt{current\_temperature}, or \texttt{subject\_id}. You want your
object names to be explicit and not too long. They cannot start with a
number (\texttt{2x} is not valid, but \texttt{x2} is). R is case
sensitive (e.g., \texttt{age} is different from \texttt{Age}). There are
some names that cannot be used because they are the names of fundamental
objects in R (e.g., \texttt{if}, \texttt{else}, \texttt{for}, see
\href{https://stat.ethz.ch/R-manual/R-devel/library/base/html/Reserved.html}{here}
for a complete list). In general, even if it's allowed, it's best to not
use them (e.g., \texttt{c}, \texttt{T}, \texttt{mean}, \texttt{data},
\texttt{df}, \texttt{weights}). If in doubt, check the help to see if
the name is already in use. It's also best to avoid dots (\texttt{.})
within an object name as in \texttt{my.dataset}. There are many objects
in R with dots in their names for historical reasons, but because dots
have a special meaning in R (for methods) and other programming
languages, it's best to avoid them. The recommended writing style is
called snake\_case, which implies using only lowercaseletters and
numbers and separating each word with underscores (e.g.,
animals\_weight, average\_income). It is also recommended to use nouns
for object names, and verbs for function names. It's important to be
consistent in the styling of your code (where you put spaces, how you
name objects, etc.). Using a consistent coding style makes your code
clearer to read for your future self and your collaborators. In R, three
popular style guides are
\href{https://google.github.io/styleguide/Rguide.xml}{Google's},
\href{https://jef.works/R-style-guide/}{Jean Fan's} and the
\href{https://style.tidyverse.org/}{tidyverse's}. The tidyverse's is
very comprehensive and may seem overwhelming at first. You can install
the \href{https://github.com/jimhester/lintr}{\textbf{\texttt{lintr}}}
package to automatically check for issues in the styling of your code.

\begin{tcolorbox}[enhanced jigsaw, opacityback=0, left=2mm, bottomrule=.15mm, toprule=.15mm, breakable, colback=white, arc=.35mm, colframe=quarto-callout-color-frame, rightrule=.15mm, leftrule=.75mm]

\vspace{-3mm}\textbf{Objects vs.~variables}\vspace{3mm}

The naming of objects in \texttt{R} is somehow related to
\texttt{variables} in many other programming languages. In many
programming languages, a variable has three aspects: a name, a memory
location, and the current value stored in this location. \texttt{R}
abstracts from modifiable memory locations. In \texttt{R} we only have
objects which cn be named. Depending on the context,
\texttt{name\ (of\ an\ object)} and \texttt{variable} can have
drastically different meanings. However, in this lesson, the two words
are used synonymously. For more information see:
\url{https://cran.r-project.org/doc/manuals/r-release/R-lang.html\#Objects}

\end{tcolorbox}

When assigning an value to a name, R does not print anything. You can
force R to print the value by using parentheses or by typing the object
name:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{area\_hectares }\OtherTok{\textless{}{-}} \FloatTok{1.0}    \CommentTok{\# doesn\textquotesingle{}t print anything}
\NormalTok{(area\_hectares }\OtherTok{\textless{}{-}} \FloatTok{1.0}\NormalTok{)  }\CommentTok{\# putting parenthesis around the call prints the value of \textasciigrave{}area\_hectares\textasciigrave{}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{area\_hectares         }\CommentTok{\# and so does typing the name of the object}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 1
\end{verbatim}

Now that R has \texttt{area\_hectares} in memory, we can do arithmetic
with it. For instance, we may want to convert this area into acres (area
in acres is 2.47 times the area in hectares):

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{2.47} \SpecialCharTok{*}\NormalTok{ area\_hectares}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 2.47
\end{verbatim}

We can also change an the value assigned to an name by assigning it a
new one:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{area\_hectares }\OtherTok{\textless{}{-}} \FloatTok{2.5}
\FloatTok{2.47} \SpecialCharTok{*}\NormalTok{ area\_hectares}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 6.175
\end{verbatim}

This means that assigning a value to one name does not change the values
of other names. For example, let's name the plot's area in acres
\texttt{area\_acres}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{area\_acres }\OtherTok{\textless{}{-}} \FloatTok{2.47} \SpecialCharTok{*}\NormalTok{ area\_hectares}
\end{Highlighting}
\end{Shaded}

and then change (reassign) \texttt{area\_hectares} to 50.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{area\_hectares }\OtherTok{\textless{}{-}} \DecValTok{50}
\end{Highlighting}
\end{Shaded}

\section{Exercise}\label{exercise}

What do you think is the current value of \texttt{area\_acres}? 123.5 or
6.175?

\begin{solution}[Solution]
The value of \texttt{area\_acres} is still 6.175 because you have not
re-run the line
\texttt{area\_acres\ \textless{}-\ 2.47\ *\ area\_hectares} since
changing the value of \texttt{area\_hectares}.
\end{solution}

\section{Comments}\label{comments}

All programming languages allow the programmer to include comments in
their code. Including comments to your code has many advantages: it
helps you explain your reasoning and it forces you to be tidy. A
commented code is also a great tool not only to your collaborators, but
to your future self. Comments are the key to a reproducible analysis.

To do this in R we use the \texttt{\#} character. Anything to the right
of the \texttt{\#} sign and up to the end of the line is treated as a
comment and is ignored by R. You can start lines with comments or
include them after any code on the line.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{area\_hectares }\OtherTok{\textless{}{-}} \FloatTok{1.0}            \CommentTok{\# land area in hectares}
\NormalTok{area\_acres }\OtherTok{\textless{}{-}}\NormalTok{ area\_hectares }\SpecialCharTok{*} \FloatTok{2.47}  \CommentTok{\# convert to acres}
\NormalTok{area\_acres              }\CommentTok{\# print land area in acres.}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 2.47
\end{verbatim}

RStudio makes it easy to comment or uncomment a paragraph: after
selecting the lines you want to comment, press at the same time on your
keyboard Ctrl + Shift + C. If you only want to comment out one line, you
can put the cursor at any location of that line (i.e.~no need to select
the whole line), then press Ctrl + Shift + C.

\section{Exercise}\label{exercise-1}

Create two variables \texttt{r\_length} and \texttt{r\_width} and assign
them values. It should be noted that, because \texttt{length} is a
built-in R function, R Studio might add ``()'' after you type
\texttt{length} and if you leave the parentheses you will get unexpected
results. This is why you might see other programmers abbreviate common
words. Create a third variable \texttt{r\_area} and give it a value
based on the current values of \texttt{r\_length} and \texttt{r\_width}.
Show that changing the values of either \texttt{r\_length} and
\texttt{r\_width} does not affect the value of \texttt{r\_area}.

\begin{solution}[Solution]
\leavevmode

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{r\_length }\OtherTok{\textless{}{-}} \FloatTok{2.5}
\NormalTok{r\_width }\OtherTok{\textless{}{-}} \FloatTok{3.2}
\NormalTok{r\_area }\OtherTok{\textless{}{-}}\NormalTok{ r\_length }\SpecialCharTok{*}\NormalTok{ r\_width}
\NormalTok{r\_area}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 8
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# change the values of r\_length and r\_width}
\NormalTok{r\_length }\OtherTok{\textless{}{-}} \FloatTok{7.0}
\NormalTok{r\_width }\OtherTok{\textless{}{-}} \FloatTok{6.5}
\CommentTok{\# the value of r\_area isn\textquotesingle{}t changed}
\NormalTok{r\_area}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 8
\end{verbatim}

\end{solution}

\subsection{Functions and their
arguments}\label{functions-and-their-arguments}

Functions are ``canned scripts'' that automate more complicated sets of
commands including operations assignments, etc. Many functions are
predefined, or can be made available by importing R \emph{packages}
(more on that later). A function usually gets one or more inputs called
\emph{arguments}. Functions often (but not always) return a
\emph{value}. A typical example would be the function \texttt{sqrt()}.
The input (the argument) must be a number, and the return value (in
fact, the output) is the square root of that number. Executing a
function (`running it') is called \emph{calling} the function. An
example of a function call is:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{b }\OtherTok{\textless{}{-}} \FunctionTok{sqrt}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

Here, the value of \texttt{a} is given to the \texttt{sqrt()} function,
the \texttt{sqrt()} function calculates the square root, and returns the
value which is then assigned to the name \texttt{b}. This function is
very simple, because it takes just one argument.

The return `value' of a function need not be numerical (like that of
\texttt{sqrt()}), and it also does not need to be a single item: it can
be a set of things, or even a dataset. We'll see that when we read data
files into R.

Arguments can be anything, not only numbers or filenames, but also other
objects. Exactly what each argument means differs per function, and must
be looked up in the documentation (see below). Some functions take
arguments which may either be specified by the user, or, if left out,
take on a \emph{default} value: these are called \emph{options}. Options
are typically used to alter the way the function operates, such as
whether it ignores `bad values', or what symbol to use in a plot.
However, if you want something specific, you can specify a value of your
choice which will be used instead of the default.

Let's try a function that can take multiple arguments: \texttt{round()}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{round}\NormalTok{(}\FloatTok{3.14159}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 3
\end{verbatim}

Here, we've called \texttt{round()} with just one argument,
\texttt{3.14159}, and it has returned the value \texttt{3}. That's
because the default is to round to the nearest whole number. If we want
more digits we can see how to do that by getting information about the
\texttt{round} function. We can use \texttt{args(round)} or look at the
help for this function using \texttt{?round}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{args}\NormalTok{(round)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
function (x, digits = 0, ...) 
NULL
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{?round}
\end{Highlighting}
\end{Shaded}

We see that if we want a different number of digits, we can type
\texttt{digits=2} or however many we want.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{round}\NormalTok{(}\FloatTok{3.14159}\NormalTok{, }\AttributeTok{digits =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 3.14
\end{verbatim}

If you provide the arguments in the exact same order as they are defined
you don't have to name them:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{round}\NormalTok{(}\FloatTok{3.14159}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 3.14
\end{verbatim}

And if you do name the arguments, you can switch their order:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{round}\NormalTok{(}\AttributeTok{digits =} \DecValTok{2}\NormalTok{, }\AttributeTok{x =} \FloatTok{3.14159}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 3.14
\end{verbatim}

It's good practice to put the non-optional arguments (like the number
you're rounding) first in your function call, and to specify the names
of all optional arguments. If you don't, someone reading your code might
have to look up the definition of a function with unfamiliar arguments
to understand what you're doing.

\section{Exercise}\label{exercise-2}

Type in \texttt{?round} at the console and then look at the output in
the Help pane. What other functions exist that are similar to
\texttt{round}? How do you use the \texttt{digits} parameter in the
round function?

\section{Vectors and data types}\label{vectors-and-data-types}

A vector is the most common and basic data type in R, and is pretty much
the workhorse of R. A vector is composed by a series of values, which
can be either numbers or characters. We can assign a series of values to
a vector using the \texttt{c()} function. For example we can create a
vector of the number of household members for the households we've
interviewed and assign it to \texttt{hh\_members}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hh\_members }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{6}\NormalTok{)}
\NormalTok{hh\_members}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1]  3  7 10  6
\end{verbatim}

A vector can also contain characters. For example, we can have a vector
of the building material used to construct our interview respondents'
walls (\texttt{respondent\_wall\_type}):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{respondent\_wall\_type }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"muddaub"}\NormalTok{, }\StringTok{"burntbricks"}\NormalTok{, }\StringTok{"sunbricks"}\NormalTok{)}
\NormalTok{respondent\_wall\_type}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "muddaub"     "burntbricks" "sunbricks"  
\end{verbatim}

The quotes around ``muddaub'', etc. are essential here. Without the
quotes R will assume there are objects called \texttt{muddaub},
\texttt{burntbricks} and \texttt{sunbricks}. As these names don't exist
in R's memory, there will be an error message.

There are many functions that allow you to inspect the content of a
vector. \texttt{length()} tells you how many elements are in a
particular vector:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{length}\NormalTok{(hh\_members)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{length}\NormalTok{(respondent\_wall\_type)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 3
\end{verbatim}

An important feature of a vector, is that all of the elements are the
same type of data. The function \texttt{typeof()} indicates the type of
an object:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{typeof}\NormalTok{(hh\_members)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "double"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{typeof}\NormalTok{(respondent\_wall\_type)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "character"
\end{verbatim}

The function \texttt{str()} provides an overview of the structure of an
object and its elements. It is a useful function when working with large
and complex objects:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str}\NormalTok{(hh\_members)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 num [1:4] 3 7 10 6
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str}\NormalTok{(respondent\_wall\_type)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 chr [1:3] "muddaub" "burntbricks" "sunbricks"
\end{verbatim}

You can use the \texttt{c()} function to add other elements to your
vector:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{possessions }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"bicycle"}\NormalTok{, }\StringTok{"radio"}\NormalTok{, }\StringTok{"television"}\NormalTok{)}
\NormalTok{possessions }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(possessions, }\StringTok{"mobile\_phone"}\NormalTok{) }\CommentTok{\# add to the end of the vector}
\NormalTok{possessions }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"car"}\NormalTok{, possessions) }\CommentTok{\# add to the beginning of the vector}
\NormalTok{possessions}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "car"          "bicycle"      "radio"        "television"   "mobile_phone"
\end{verbatim}

In the first line, we take the original vector \texttt{possessions}, add
the value \texttt{"mobile\_phone"} to the end of it, and save the result
back into \texttt{possessions}. Then we add the value \texttt{"car"} to
the beginning, again saving the result back into \texttt{possessions}.

We can do this over and over again to grow a vector, or assemble a
dataset. As we program, this may be useful to add results that we are
collecting or calculating.

An \textbf{atomic vector} is the simplest R \textbf{data type} and is a
linear vector of a single type. Above, we saw 2 of the 6 main
\textbf{atomic vector} types that R uses: \texttt{"character"} and
\texttt{"numeric"} (or \texttt{"double"}). These are the basic building
blocks that all R objects are built from. The other 4 \textbf{atomic
vector} types are:

\begin{itemize}
\tightlist
\item
  \texttt{"logical"} for \texttt{TRUE} and \texttt{FALSE} (the boolean
  data type)
\item
  \texttt{"integer"} for integer numbers (e.g., \texttt{2L}, the
  \texttt{L} indicates to R that it's an integer)
\item
  \texttt{"complex"} to represent complex numbers with real and
  imaginary parts (e.g., \texttt{1\ +\ 4i}) and that's all we're going
  to say about them
\item
  \texttt{"raw"} for bitstreams that we won't discuss further
\end{itemize}

You can check the type of your vector using the \texttt{typeof()}
function and inputting your vector as the argument.

Vectors are one of the many \textbf{data structures} that R uses. Other
important ones are lists (\texttt{list}), matrices (\texttt{matrix}),
data frames (\texttt{data.frame}), factors (\texttt{factor}) and arrays
(\texttt{array}).

\section{Exercise}\label{exercise-3}

We've seen that atomic vectors can be of type character, numeric (or
double), integer, and logical. But what happens if we try to mix these
types in a single vector?

\begin{solution}[Solution]
R implicitly converts them to all be the same type.
\end{solution}

What will happen in each of these examples? (hint: use \texttt{class()}
to check the data type of your objects):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{num\_char }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\StringTok{"a"}\NormalTok{)}
\NormalTok{num\_logical }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\ConstantTok{TRUE}\NormalTok{)}
\NormalTok{char\_logical }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{, }\ConstantTok{TRUE}\NormalTok{)}
\NormalTok{tricky }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\StringTok{"4"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Why do you think it happens?

\begin{solution}[Solution]
Vectors can be of only one data type. R tries to convert (coerce) the
content of this vector to find a ``common denominator'' that doesn't
lose any information.
\end{solution}

How many values in \texttt{combined\_logical} are \texttt{"TRUE"} (as a
character) in the following example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{num\_logical }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\ConstantTok{TRUE}\NormalTok{)}
\NormalTok{char\_logical }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{, }\ConstantTok{TRUE}\NormalTok{)}
\NormalTok{combined\_logical }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(num\_logical, char\_logical)}
\end{Highlighting}
\end{Shaded}

\begin{solution}[Solution]
Only one. There is no memory of past data types, and the coercion
happens the first time the vector is evaluated. Therefore, the
\texttt{TRUE} in \texttt{num\_logical} gets converted into a \texttt{1}
before it gets converted into \texttt{"1"} in
\texttt{combined\_logical}.
\end{solution}

You've probably noticed that objects of different types get converted
into a single, shared type within a vector. In R, we call converting
objects from one class into another class \emph{coercion}. These
conversions happen according to a hierarchy, whereby some types get
preferentially coerced into other types. Can you draw a diagram that
represents the hierarchy of how these data types are coerced?

\section{Subsetting vectors}\label{subsetting-vectors}

Subsetting (sometimes referred to as extracting or indexing) involves
accessing out one or more values based on their numeric placement or
``index'' within a vector. If we want to subset one or several values
from a vector, we must provide one index or several indices in square
brackets. For instance:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{respondent\_wall\_type }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"muddaub"}\NormalTok{, }\StringTok{"burntbricks"}\NormalTok{, }\StringTok{"sunbricks"}\NormalTok{)}
\NormalTok{respondent\_wall\_type[}\DecValTok{2}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "burntbricks"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{respondent\_wall\_type[}\FunctionTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "sunbricks"   "burntbricks"
\end{verbatim}

We can also repeat the indices to create an object with more elements
than the original one:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{more\_respondent\_wall\_type }\OtherTok{\textless{}{-}}\NormalTok{ respondent\_wall\_type[}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{)]}
\NormalTok{more\_respondent\_wall\_type}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "muddaub"     "burntbricks" "sunbricks"   "burntbricks" "muddaub"    
[6] "sunbricks"  
\end{verbatim}

R indices start at 1. Programming languages like Fortran, MATLAB, Julia,
and R start counting at 1, because that's what human beings typically
do. Languages in the C family (including C++, Java, Perl, and Python)
count from 0 because that's simpler for computers to do.

\subsection{Conditional subsetting}\label{conditional-subsetting}

Another common way of subsetting is by using a logical vector.
\texttt{TRUE} will select the element with the same index, while
\texttt{FALSE} will not:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hh\_members }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{6}\NormalTok{)}
\NormalTok{hh\_members[}\FunctionTok{c}\NormalTok{(}\ConstantTok{TRUE}\NormalTok{, }\ConstantTok{FALSE}\NormalTok{, }\ConstantTok{TRUE}\NormalTok{, }\ConstantTok{TRUE}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1]  3 10  6
\end{verbatim}

Typically, these logical vectors are not typed by hand, but are the
output of other functions or logical tests. For instance, if you wanted
to select only the values above 5:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hh\_members }\SpecialCharTok{\textgreater{}} \DecValTok{5}    \CommentTok{\# will return logicals with TRUE for the indices that meet the condition}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] FALSE  TRUE  TRUE  TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# so we can use this to select only the values above 5}
\NormalTok{hh\_members[hh\_members }\SpecialCharTok{\textgreater{}} \DecValTok{5}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1]  7 10  6
\end{verbatim}

You can combine multiple tests using \texttt{\&} (both conditions are
true, AND) or \texttt{\textbar{}} (at least one of the conditions is
true, OR):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hh\_members[hh\_members }\SpecialCharTok{\textless{}} \DecValTok{4} \SpecialCharTok{|}\NormalTok{ hh\_members }\SpecialCharTok{\textgreater{}} \DecValTok{7}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1]  3 10
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hh\_members[hh\_members }\SpecialCharTok{\textgreater{}=} \DecValTok{4} \SpecialCharTok{\&}\NormalTok{ hh\_members }\SpecialCharTok{\textless{}=} \DecValTok{7}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 7 6
\end{verbatim}

Here, \texttt{\textless{}} stands for ``less than'',
\texttt{\textgreater{}} for ``greater than'', \texttt{\textgreater{}=}
for ``greater than or equal to'', and \texttt{==} for ``equal to''. The
double equal sign \texttt{==} is a test for numerical equality between
the left and right hand sides, and should not be confused with the
single \texttt{=} sign, which performs variable assignment (similar to
\texttt{\textless{}-}).

A common task is to search for certain strings in a vector. One could
use the ``or'' operator \texttt{\textbar{}} to test for equality to
multiple values, but this can quickly become tedious.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{possessions }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"car"}\NormalTok{, }\StringTok{"bicycle"}\NormalTok{, }\StringTok{"radio"}\NormalTok{, }\StringTok{"television"}\NormalTok{, }\StringTok{"mobile\_phone"}\NormalTok{)}
\NormalTok{possessions[possessions }\SpecialCharTok{==} \StringTok{"car"} \SpecialCharTok{|}\NormalTok{ possessions }\SpecialCharTok{==} \StringTok{"bicycle"}\NormalTok{] }\CommentTok{\# returns both car and bicycle}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "car"     "bicycle"
\end{verbatim}

The function \texttt{\%in\%} allows you to test if any of the elements
of a search vector (on the left hand side) are found in the target
vector (on the right hand side):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{possessions }\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\StringTok{"car"}\NormalTok{, }\StringTok{"bicycle"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1]  TRUE  TRUE FALSE FALSE FALSE
\end{verbatim}

Note that the output is the same length as the search vector on the left
hand side, because \texttt{\%in\%} checks whether each element of the
search vector is found somewhere in the target vector. Thus, you can use
\texttt{\%in\%} to select the elements in the search vector that appear
in your target vector:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{possessions }\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\StringTok{"car"}\NormalTok{, }\StringTok{"bicycle"}\NormalTok{, }\StringTok{"motorcycle"}\NormalTok{, }\StringTok{"truck"}\NormalTok{, }\StringTok{"boat"}\NormalTok{, }\StringTok{"bus"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1]  TRUE  TRUE FALSE FALSE FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{possessions[possessions }\SpecialCharTok{\%in\%} \FunctionTok{c}\NormalTok{(}\StringTok{"car"}\NormalTok{, }\StringTok{"bicycle"}\NormalTok{, }\StringTok{"motorcycle"}\NormalTok{, }\StringTok{"truck"}\NormalTok{, }\StringTok{"boat"}\NormalTok{, }\StringTok{"bus"}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "car"     "bicycle"
\end{verbatim}

\section{Missing data}\label{missing-data}

As R was designed to analyze datasets, it includes the concept of
missing data (which is uncommon in other programming languages). Missing
data are represented in vectors as \texttt{NA}.

When doing operations on numbers, most functions will return \texttt{NA}
if the data you are working with include missing values. This feature
makes it harder to overlook the cases where you are dealing with missing
data. You can add the argument \texttt{na.rm=TRUE} to calculate the
result while ignoring the missing values.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rooms }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\ConstantTok{NA}\NormalTok{, }\DecValTok{7}\NormalTok{)}
\FunctionTok{mean}\NormalTok{(rooms)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] NA
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{max}\NormalTok{(rooms)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] NA
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{(rooms, }\AttributeTok{na.rm =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 2.75
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{max}\NormalTok{(rooms, }\AttributeTok{na.rm =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 7
\end{verbatim}

If your data include missing values, you may want to become familiar
with the functions \texttt{is.na()}, \texttt{na.omit()}, and
\texttt{complete.cases()}. See below for examples.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Extract those elements which are not missing values.}
\DocumentationTok{\#\# The ! character is also called the NOT operator}
\NormalTok{rooms[}\SpecialCharTok{!}\FunctionTok{is.na}\NormalTok{(rooms)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 2 1 1 7
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Count the number of missing values.}
\DocumentationTok{\#\# The output of is.na() is a logical vector (TRUE/FALSE equivalent to 1/0) so the sum() function here is effectively counting}
\FunctionTok{sum}\NormalTok{(}\FunctionTok{is.na}\NormalTok{(rooms))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Returns the object with incomplete cases removed. The returned object is an atomic vector of type \textasciigrave{}"numeric"\textasciigrave{} (or \textasciigrave{}"double"\textasciigrave{}).}
\FunctionTok{na.omit}\NormalTok{(rooms)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 2 1 1 7
attr(,"na.action")
[1] 4
attr(,"class")
[1] "omit"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Extract those elements which are complete cases. The returned object is an atomic vector of type \textasciigrave{}"numeric"\textasciigrave{} (or \textasciigrave{}"double"\textasciigrave{}).}
\NormalTok{rooms[}\FunctionTok{complete.cases}\NormalTok{(rooms)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 2 1 1 7
\end{verbatim}

Recall that you can use the \texttt{typeof()} function to find the type
of your atomic vector.

\section{Exercise}\label{exercise-4}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Using this vector of rooms, create a new vector with the NAs removed.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rooms }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\ConstantTok{NA}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{, }\ConstantTok{NA}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  Use the function \texttt{median()} to calculate the median of the
  \texttt{rooms} vector.
\item
  Use R to figure out how many households in the set use more than 2
  rooms for sleeping.
\end{enumerate}

\begin{solution}[Solution]
\leavevmode

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rooms }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\ConstantTok{NA}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{, }\ConstantTok{NA}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\NormalTok{rooms\_no\_na }\OtherTok{\textless{}{-}}\NormalTok{ rooms[}\SpecialCharTok{!}\FunctionTok{is.na}\NormalTok{(rooms)]}
\CommentTok{\# or}
\NormalTok{rooms\_no\_na }\OtherTok{\textless{}{-}} \FunctionTok{na.omit}\NormalTok{(rooms)}
\CommentTok{\# 2.}
\FunctionTok{median}\NormalTok{(rooms, }\AttributeTok{na.rm =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# 3.}
\NormalTok{rooms\_above\_2 }\OtherTok{\textless{}{-}}\NormalTok{ rooms\_no\_na[rooms\_no\_na }\SpecialCharTok{\textgreater{}} \DecValTok{2}\NormalTok{]}
\FunctionTok{length}\NormalTok{(rooms\_above\_2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 4
\end{verbatim}

\end{solution}

Now that we have learned how to write scripts, and the basics of R's
data structures, we are ready to start working with the SAFI dataset we
have been using in the other lessons, and learn about data frames.

\begin{itemize}
\tightlist
\item
  Access individual values by location using \texttt{{[}{]}}.
\item
  Access arbitrary sets of data using \texttt{{[}c(...){]}}.
\item
  Use logical operations and logical vectors to access subsets of data.
\end{itemize}

\bookmarksetup{startatroot}

\chapter{Starting with Data}\label{starting-with-data}

The two main goals for this lessons are:

\begin{itemize}
\tightlist
\item
  To make sure that learners are comfortable with working with data
  frames, and can use the bracket notation to select slices/columns.
\item
  To expose learners to factors. Their behavior is not necessarily
  intuitive, and so it is important that they are guided through it the
  first time they are exposed to it. The content of the lesson should be
  enough for learners to avoid common mistakes with them.
\end{itemize}

\begin{itemize}
\tightlist
\item
  Describe what a data frame is.
\item
  Load external data from a .csv file into a data frame.
\item
  Summarize the contents of a data frame.
\item
  Subset values from data frames.
\item
  Describe the difference between a factor and a string.
\item
  Convert between strings and factors.
\item
  Reorder and rename factors.
\item
  Change how character strings are handled in a data frame.
\item
  Examine and change date formats.
\end{itemize}

\begin{itemize}
\tightlist
\item
  What is a data.frame?
\item
  How can I read a complete csv file into R?
\item
  How can I get basic summary information about my dataset?
\item
  How can I change the way R treats strings in my dataset?
\item
  Why would I want strings to be treated differently?
\item
  How are dates represented in R and how can I change the format?
\end{itemize}

\section{What are data frames?}\label{what-are-data-frames}

Data frames are the \emph{de facto} data structure for tabular data in
\texttt{R}, and what we use for data processing, statistics, and
plotting.

A data frame is the representation of data in the format of a table
where the columns are vectors that all have the same length. Data frames
are analogous to the more familiar spreadsheet in programs such as
Excel, with one key difference. Because columns are vectors, each column
must contain a single type of data (e.g., characters, integers,
factors). For example, here is a figure depicting a data frame
comprising a numeric, a character, and a logical vector.

\pandocbounded{\includegraphics[keepaspectratio]{index_files/mediabag/fig/data-frame.pdf}}

Data frames can be created by hand, but most commonly they are generated
by the functions \texttt{read\_csv()} or \texttt{read\_table()}; in
other words, when importing spreadsheets from your hard drive (or the
web). We will now demonstrate how to import tabular data using
\texttt{read\_csv()}.

\section{Presentation of the SAFI
Data}\label{presentation-of-the-safi-data}

SAFI (Studying African Farmer-Led Irrigation) is a study looking at
farming and irrigation methods in Tanzania and Mozambique. The survey
data was collected through interviews conducted between November 2016
and June 2017. For this lesson, we will be using a subset of the
available data. For information about the full teaching dataset used in
other lessons in this workshop, see the
\href{https://datacarpentry.org/socialsci-workshop/index.html\#data}{dataset
description}.

We will be using a subset of the cleaned version of the dataset that was
produced through cleaning in OpenRefine (\texttt{data/SAFI\_clean.csv}).
In this dataset, the missing data is encoded as ``NULL'', each row holds
information for a single interview respondent, and the columns
represent:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.1351}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.8649}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
column\_name
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
key\_id & Added to provide a unique Id for each observation. (The
InstanceID field does this as well but it is not as convenient to
use) \\
village & Village name \\
interview\_date & Date of interview \\
no\_membrs & How many members in the household? \\
years\_liv & How many years have you been living in this village or
neighboring village? \\
respondent\_wall\_type & What type of walls does their house have (from
list) \\
rooms & How many rooms in the main house are used for sleeping? \\
memb\_assoc & Are you a member of an irrigation association? \\
affect\_conflicts & Have you been affected by conflicts with other
irrigators in the area? \\
liv\_count & Number of livestock owned. \\
items\_owned & Which of the following items are owned by the household?
(list) \\
no\_meals & How many meals do people in your household normally eat in a
day? \\
months\_lack\_food & Indicate which months, In the last 12 months have
you faced a situation when you did not have enough food to feed the
household? \\
instanceID & Unique identifier for the form data submission \\
\end{longtable}

\section{Importing data}\label{importing-data}

You are going to load the data in R's memory using the function
\texttt{read\_csv()} from the \textbf{\texttt{readr}} package, which is
part of the \textbf{\texttt{tidyverse}}; learn more about the
\textbf{\texttt{tidyverse}} collection of packages
\href{https://www.tidyverse.org/}{here}. \textbf{\texttt{readr}} gets
installed as part as the \textbf{\texttt{tidyverse}} installation. When
you load the \textbf{\texttt{tidyverse}} (\texttt{library(tidyverse)}),
the core packages (the packages used in most data analyses) get loaded,
including \textbf{\texttt{readr}}.

Before proceeding, however, this is a good opportunity to talk about
conflicts. Certain packages we load can end up introducing function
names that are already in use by pre-loaded R packages. For instance,
when we load the tidyverse package below, we will introduce two
conflicting functions: \texttt{filter()} and \texttt{lag()}. This
happens because \texttt{filter} and \texttt{lag} are already functions
used by the stats package (already pre-loaded in R). What will happen
now is that if we, for example, call the \texttt{filter()} function, R
will use the \texttt{dplyr::filter()} version and not the
\texttt{stats::filter()} one. This happens because, if conflicted, by
default R uses the function from the most recently loaded package.
Conflicted functions may cause you some trouble in the future, so it is
important that we are aware of them so that we can properly handle them,
if we want.

To do so, we just need the following functions from the conflicted
package:

\begin{itemize}
\tightlist
\item
  \texttt{conflicted::conflict\_scout()}: Shows us any conflicted
  functions.\\
\item
  \texttt{conflict\_prefer("function",\ "package\_prefered")}: Allows us
  to choose the default function we want from now on.
\end{itemize}

It is also important to know that we can, at any time, just call the
function directly from the package we want, such as
\texttt{stats::filter()}.

Even with the use of an RStudio project, it can be difficult to learn
how to specify paths to file locations. Enter the \textbf{here} package!
The here package creates paths relative to the top-level directory (your
RStudio project). These relative paths work \emph{regardless} of where
the associated source file lives inside your project, like analysis
projects with data and reports in different subdirectories. This is an
important contrast to using \texttt{setwd()}, which depends on the way
you order your files on your computer.

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{fig/here_horst.png}

Image credit: Allison Horst

Before we can use the \texttt{read\_csv()} and \texttt{here()}
functions, we need to load the tidyverse and here packages.

Also, if you recall, the missing data is encoded as ``NULL'' in the
dataset. We'll tell it to the function, so R will automatically convert
all the ``NULL'' entries in the dataset into \texttt{NA}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{library}\NormalTok{(here)}

\NormalTok{interviews }\OtherTok{\textless{}{-}} \FunctionTok{read\_csv}\NormalTok{(}
  \FunctionTok{here}\NormalTok{(}\StringTok{"data"}\NormalTok{, }\StringTok{"SAFI\_clean.csv"}\NormalTok{), }
  \AttributeTok{na =} \StringTok{"NULL"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

In the above code, we notice the \texttt{here()} function takes folder
and file names as inputs (e.g., \texttt{"data"},
\texttt{"SAFI\_clean.csv"}), each enclosed in quotations (\texttt{""})
and separated by a comma. The \texttt{here()} will accept as many names
as are necessary to navigate to a particular file (e.g.,
\texttt{here("analysis",\ "data",\ "surveys",\ "clean",\ "SAFI\_clean.csv)}).

The \texttt{here()} function can accept the folder and file names in an
alternate format, using a slash (``/'') rather than commas to separate
the names. The two methods are equivalent, so that
\texttt{here("data",\ "SAFI\_clean.csv")} and
\texttt{here("data/SAFI\_clean.csv")} produce the same result. (The
slash is used on all operating systems; backslashes are not used.)

If you were to type in the code above, it is likely that the
\texttt{read.csv()} function would appear in the automatically populated
list of functions. This function is different from the
\texttt{read\_csv()} function, as it is included in the ``base''
packages that come pre-installed with R. Overall, \texttt{read.csv()}
behaves similar to \texttt{read\_csv()}, with a few notable differences.
First, \texttt{read.csv()} coerces column names with spaces and/or
special characters to different names (e.g.~\texttt{interview\ date}
becomes \texttt{interview.date}). Second, \texttt{read.csv()} stores
data as a \texttt{data.frame}, where \texttt{read\_csv()} stores data as
a different kind of data frame called a \texttt{tibble}. We prefer
tibbles because they have nice printing properties among other desirable
qualities. Read more about tibbles
\href{https://tibble.tidyverse.org/}{here}.

The second statement in the code above creates a data frame but doesn't
output any data because, as you might recall, assignments
(\texttt{\textless{}-}) don't display anything. (Note, however, that
\texttt{read\_csv} may show informational text about the data frame that
is created.) If we want to check that our data has been loaded, we can
see the contents of the data frame by typing its name:
\texttt{interviews} in the console.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews}
\DocumentationTok{\#\# Try also}
\DocumentationTok{\#\# view(interviews)}
\DocumentationTok{\#\# head(interviews)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 131 x 14
   key_ID village  interview_date      no_membrs years_liv respondent_wall_type
    <dbl> <chr>    <dttm>                  <dbl>     <dbl> <chr>               
 1      1 God      2016-11-17 00:00:00         3         4 muddaub             
 2      2 God      2016-11-17 00:00:00         7         9 muddaub             
 3      3 God      2016-11-17 00:00:00        10        15 burntbricks         
 4      4 God      2016-11-17 00:00:00         7         6 burntbricks         
 5      5 God      2016-11-17 00:00:00         7        40 burntbricks         
 6      6 God      2016-11-17 00:00:00         3         3 muddaub             
 7      7 God      2016-11-17 00:00:00         6        38 muddaub             
 8      8 Chirodzo 2016-11-16 00:00:00        12        70 burntbricks         
 9      9 Chirodzo 2016-11-16 00:00:00         8         6 burntbricks         
10     10 Chirodzo 2016-12-16 00:00:00        12        23 burntbricks         
# i 121 more rows
# i 8 more variables: rooms <dbl>, memb_assoc <chr>, affect_conflicts <chr>,
#   liv_count <dbl>, items_owned <chr>, no_meals <dbl>, months_lack_food <chr>,
#   instanceID <chr>
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, opacityback=0, left=2mm, bottomrule=.15mm, toprule=.15mm, breakable, colback=white, arc=.35mm, colframe=quarto-callout-color-frame, rightrule=.15mm, leftrule=.75mm]

\vspace{-3mm}\textbf{Note}\vspace{3mm}

\texttt{read\_csv()} assumes that fields are delimited by commas.
However, in several countries, the comma is used as a decimal separator
and the semicolon (;) is used as a field delimiter. If you want to read
in this type of files in R, you can use the \texttt{read\_csv2}
function. It behaves exactly like \texttt{read\_csv} but uses different
parameters for the decimal and the field separators. If you are working
with another format, they can be both specified by the user. Check out
the help for \texttt{read\_csv()} by typing \texttt{?read\_csv} to learn
more. There is also the \texttt{read\_tsv()} for tab-separated data
files, and \texttt{read\_delim()} allows you to specify more details
about the structure of your file.

\end{tcolorbox}

Note that \texttt{read\_csv()} actually loads the data as a tibble. A
tibble is an extension of \texttt{R} data frames used by the
\textbf{\texttt{tidyverse}}. When the data is read using
\texttt{read\_csv()}, it is stored in an object of class
\texttt{tbl\_df}, \texttt{tbl}, and \texttt{data.frame}. You can see the
class of an object with

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(interviews)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "spec_tbl_df" "tbl_df"      "tbl"         "data.frame" 
\end{verbatim}

As a \texttt{tibble}, the type of data included in each column is listed
in an abbreviated fashion below the column names. For instance, here
\texttt{key\_ID} is a column of floating point numbers (abbreviated
\texttt{\textless{}dbl\textgreater{}} for the word `double'),
\texttt{village} is a column of characters
(\texttt{\textless{}chr\textgreater{}}) and the \texttt{interview\_date}
is a column in the ``date and time'' format
(\texttt{\textless{}dttm\textgreater{}}).

\section{Inspecting data frames}\label{inspecting-data-frames}

When calling a \texttt{tbl\_df} object (like \texttt{interviews} here),
there is already a lot of information about our data frame being
displayed such as the number of rows, the number of columns, the names
of the columns, and as we just saw the class of data stored in each
column. However, there are functions to extract this information from
data frames. Here is a non-exhaustive list of some of these functions.
Let's try them out!

Size:

\begin{itemize}
\tightlist
\item
  \texttt{dim(interviews)} - returns a vector with the number of rows as
  the first element, and the number of columns as the second element
  (the \textbf{dim}ensions of the object)
\item
  \texttt{nrow(interviews)} - returns the number of rows
\item
  \texttt{ncol(interviews)} - returns the number of columns
\end{itemize}

Content:

\begin{itemize}
\tightlist
\item
  \texttt{head(interviews)} - shows the first 6 rows
\item
  \texttt{tail(interviews)} - shows the last 6 rows
\end{itemize}

Names:

\begin{itemize}
\tightlist
\item
  \texttt{names(interviews)} - returns the column names (synonym of
  \texttt{colnames()} for \texttt{data.frame} objects)
\end{itemize}

Summary:

\begin{itemize}
\tightlist
\item
  \texttt{str(interviews)} - structure of the object and information
  about the class, length and content of each column
\item
  \texttt{summary(interviews)} - summary statistics for each column
\item
  \texttt{glimpse(interviews)} - returns the number of columns and rows
  of the tibble, the names and class of each column, and previews as
  many values will fit on the screen. Unlike the other inspecting
  functions listed above, \texttt{glimpse()} is not a ``base R''
  function so you need to have the \texttt{dplyr} or \texttt{tibble}
  packages loaded to be able to execute it.
\end{itemize}

Note: most of these functions are ``generic.'' They can be used on other
types of objects besides data frames or tibbles.

\section{Subsetting data frames}\label{subsetting-data-frames}

Our \texttt{interviews} data frame has rows and columns (it has 2
dimensions). In practice, we may not need the entire data frame; for
instance, we may only be interested in a subset of the observations (the
rows) or a particular set of variables (the columns). If we want to
access some specific data from it, we need to specify the
``coordinates'' (i.e., indices) we want from it. Row numbers come first,
followed by column numbers.

\begin{tcolorbox}[enhanced jigsaw, opacityback=0, left=2mm, bottomrule=.15mm, toprule=.15mm, breakable, colback=white, arc=.35mm, colframe=quarto-callout-color-frame, rightrule=.15mm, leftrule=.75mm]

\vspace{-3mm}\textbf{Tip}\vspace{3mm}

Subsetting a \texttt{tibble} with \texttt{{[}} always results in a
\texttt{tibble}. However, note this is not true in general for data
frames, so be careful! Different ways of specifying these coordinates
can lead to results with different classes. This is covered in the
Software Carpentry lesson
\href{https://swcarpentry.github.io/r-novice-gapminder/}{R for
Reproducible Scientific Analysis}.

\end{tcolorbox}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# first element in the first column of the tibble}
\NormalTok{interviews[}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 1 x 1
  key_ID
   <dbl>
1      1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# first element in the 6th column of the tibble }
\NormalTok{interviews[}\DecValTok{1}\NormalTok{, }\DecValTok{6}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 1 x 1
  respondent_wall_type
  <chr>               
1 muddaub             
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# first column of the tibble (as a vector)}
\NormalTok{interviews[[}\DecValTok{1}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
  [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18
 [19]  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36
 [37]  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54
 [55]  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71 127
 [73] 133 152 153 155 178 177 180 181 182 186 187 195 196 197 198 201 202  72
 [91]  73  76  83  85  89 101 103 102  78  80 104 105 106 109 110 113 118 125
[109] 119 115 108 116 117 144 143 150 159 160 165 166 167 174 175 189 191 192
[127] 126 193 194 199 200
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# first column of the tibble}
\NormalTok{interviews[}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 131 x 1
   key_ID
    <dbl>
 1      1
 2      2
 3      3
 4      4
 5      5
 6      6
 7      7
 8      8
 9      9
10     10
# i 121 more rows
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# first three elements in the 7th column of the tibble}
\NormalTok{interviews[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{, }\DecValTok{7}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 3 x 1
  rooms
  <dbl>
1     1
2     1
3     1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# the 3rd row of the tibble}
\NormalTok{interviews[}\DecValTok{3}\NormalTok{, ]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 1 x 14
  key_ID village interview_date      no_membrs years_liv respondent_wall_type
   <dbl> <chr>   <dttm>                  <dbl>     <dbl> <chr>               
1      3 God     2016-11-17 00:00:00        10        15 burntbricks         
# i 8 more variables: rooms <dbl>, memb_assoc <chr>, affect_conflicts <chr>,
#   liv_count <dbl>, items_owned <chr>, no_meals <dbl>, months_lack_food <chr>,
#   instanceID <chr>
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# equivalent to head\_interviews \textless{}{-} head(interviews)}
\NormalTok{head\_interviews }\OtherTok{\textless{}{-}}\NormalTok{ interviews[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{6}\NormalTok{, ]}
\end{Highlighting}
\end{Shaded}

\texttt{:} is a special function that creates numeric vectors of
integers in increasing or decreasing order, test \texttt{1:10} and
\texttt{10:1} for instance.

You can also exclude certain indices of a data frame using the
``\texttt{-}'' sign:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews[, }\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{]          }\CommentTok{\# The whole tibble, except the first column}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 131 x 13
   village  interview_date      no_membrs years_liv respondent_wall_type rooms
   <chr>    <dttm>                  <dbl>     <dbl> <chr>                <dbl>
 1 God      2016-11-17 00:00:00         3         4 muddaub                  1
 2 God      2016-11-17 00:00:00         7         9 muddaub                  1
 3 God      2016-11-17 00:00:00        10        15 burntbricks              1
 4 God      2016-11-17 00:00:00         7         6 burntbricks              1
 5 God      2016-11-17 00:00:00         7        40 burntbricks              1
 6 God      2016-11-17 00:00:00         3         3 muddaub                  1
 7 God      2016-11-17 00:00:00         6        38 muddaub                  1
 8 Chirodzo 2016-11-16 00:00:00        12        70 burntbricks              3
 9 Chirodzo 2016-11-16 00:00:00         8         6 burntbricks              1
10 Chirodzo 2016-12-16 00:00:00        12        23 burntbricks              5
# i 121 more rows
# i 7 more variables: memb_assoc <chr>, affect_conflicts <chr>,
#   liv_count <dbl>, items_owned <chr>, no_meals <dbl>, months_lack_food <chr>,
#   instanceID <chr>
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews[}\SpecialCharTok{{-}}\FunctionTok{c}\NormalTok{(}\DecValTok{7}\SpecialCharTok{:}\DecValTok{131}\NormalTok{), ]   }\CommentTok{\# Equivalent to head(interviews)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 6 x 14
  key_ID village interview_date      no_membrs years_liv respondent_wall_type
   <dbl> <chr>   <dttm>                  <dbl>     <dbl> <chr>               
1      1 God     2016-11-17 00:00:00         3         4 muddaub             
2      2 God     2016-11-17 00:00:00         7         9 muddaub             
3      3 God     2016-11-17 00:00:00        10        15 burntbricks         
4      4 God     2016-11-17 00:00:00         7         6 burntbricks         
5      5 God     2016-11-17 00:00:00         7        40 burntbricks         
6      6 God     2016-11-17 00:00:00         3         3 muddaub             
# i 8 more variables: rooms <dbl>, memb_assoc <chr>, affect_conflicts <chr>,
#   liv_count <dbl>, items_owned <chr>, no_meals <dbl>, months_lack_food <chr>,
#   instanceID <chr>
\end{verbatim}

\texttt{tibble}s can be subset by calling indices (as shown previously),
but also by calling their column names directly:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews[}\StringTok{"village"}\NormalTok{]       }\CommentTok{\# Result is a tibble}

\NormalTok{interviews[, }\StringTok{"village"}\NormalTok{]     }\CommentTok{\# Result is a tibble}

\NormalTok{interviews[[}\StringTok{"village"}\NormalTok{]]     }\CommentTok{\# Result is a vector}

\NormalTok{interviews}\SpecialCharTok{$}\NormalTok{village          }\CommentTok{\# Result is a vector}
\end{Highlighting}
\end{Shaded}

In RStudio, you can use the autocompletion feature to get the full and
correct names of the columns.

\section{Exercise}\label{exercise-5}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create a tibble (\texttt{interviews\_100}) containing only the data in
  row 100 of the \texttt{interviews} dataset.
\end{enumerate}

Now, continue using \texttt{interviews} for each of the following
activities:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Notice how \texttt{nrow()} gave you the number of rows in the tibble?
\end{enumerate}

\begin{itemize}
\tightlist
\item
  Use that number to pull out just that last row in the tibble.
\item
  Compare that with what you see as the last row using \texttt{tail()}
  to make sure it's meeting expectations.
\item
  Pull out that last row using \texttt{nrow()} instead of the row
  number.
\item
  Create a new tibble (\texttt{interviews\_last}) from that last row.
\end{itemize}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Using the number of rows in the interviews dataset that you found in
  question 2, extract the row that is in the middle of the dataset.
  Store the content of this middle row in an object named
  \texttt{interviews\_middle}. (hint: This dataset has an odd number of
  rows, so finding the middle is a bit trickier than dividing n\_rows by
  2. Use the median( ) function and what you've learned about sequences
  in R to extract the middle row!
\item
  Combine \texttt{nrow()} with the \texttt{-} notation above to
  reproduce the behavior of \texttt{head(interviews)}, keeping just the
  first through 6th rows of the interviews dataset.
\end{enumerate}

\begin{solution}[Solution]
\leavevmode

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# 1.}
\NormalTok{interviews\_100 }\OtherTok{\textless{}{-}}\NormalTok{ interviews[}\DecValTok{100}\NormalTok{, ]}
\DocumentationTok{\#\# 2.}
\CommentTok{\# Saving \textasciigrave{}n\_rows\textasciigrave{} to improve readability and reduce duplication}
\NormalTok{n\_rows }\OtherTok{\textless{}{-}} \FunctionTok{nrow}\NormalTok{(interviews)}
\NormalTok{interviews\_last }\OtherTok{\textless{}{-}}\NormalTok{ interviews[n\_rows, ]}
\DocumentationTok{\#\# 3.}
\NormalTok{interviews\_middle }\OtherTok{\textless{}{-}}\NormalTok{ interviews[}\FunctionTok{median}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\NormalTok{n\_rows), ]}
\DocumentationTok{\#\# 4.}
\NormalTok{interviews\_head }\OtherTok{\textless{}{-}}\NormalTok{ interviews[}\SpecialCharTok{{-}}\NormalTok{(}\DecValTok{7}\SpecialCharTok{:}\NormalTok{n\_rows), ]}
\end{Highlighting}
\end{Shaded}

\end{solution}

\section{Factors}\label{factors}

R has a special data class, called factor, to deal with categorical data
that you may encounter when creating plots or doing statistical
analyses. Factors are very useful and actually contribute to making R
particularly well suited to working with data. So we are going to spend
a little time introducing them.

Factors represent categorical data. They are stored as integers
associated with labels and they can be ordered (ordinal) or unordered
(nominal). Factors create a structured relation between the different
levels (values) of a categorical variable, such as days of the week or
responses to a question in a survey. This can make it easier to see how
one element relates to the other elements in a column. While factors
look (and often behave) like character vectors, they are actually
treated as integer vectors by \texttt{R}. So you need to be very careful
when treating them as strings.

Once created, factors can only contain a pre-defined set of values,
known as \emph{levels}. By default, R always sorts levels in
alphabetical order. For instance, if you have a factor with 2 levels:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{respondent\_floor\_type }\OtherTok{\textless{}{-}} \FunctionTok{factor}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"earth"}\NormalTok{, }\StringTok{"cement"}\NormalTok{, }\StringTok{"cement"}\NormalTok{, }\StringTok{"earth"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

R will assign \texttt{1} to the level \texttt{"cement"} and \texttt{2}
to the level \texttt{"earth"} (because \texttt{c} comes before
\texttt{e}, even though the first element in this vector is
\texttt{"earth"}). You can see this by using the function
\texttt{levels()} and you can find the number of levels using
\texttt{nlevels()}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{levels}\NormalTok{(respondent\_floor\_type)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "cement" "earth" 
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{nlevels}\NormalTok{(respondent\_floor\_type)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 2
\end{verbatim}

Sometimes, the order of the factors does not matter. Other times you
might want to specify the order because it is meaningful (e.g., ``low'',
``medium'', ``high''). It may improve your visualization, or it may be
required by a particular type of analysis. Here, one way to reorder our
levels in the \texttt{respondent\_floor\_type} vector would be:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{respondent\_floor\_type }\CommentTok{\# current order}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] earth  cement cement earth 
Levels: cement earth
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{respondent\_floor\_type }\OtherTok{\textless{}{-}} \FunctionTok{factor}\NormalTok{(respondent\_floor\_type, }
                                \AttributeTok{levels =} \FunctionTok{c}\NormalTok{(}\StringTok{"earth"}\NormalTok{, }\StringTok{"cement"}\NormalTok{))}

\NormalTok{respondent\_floor\_type }\CommentTok{\# after re{-}ordering}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] earth  cement cement earth 
Levels: earth cement
\end{verbatim}

In R's memory, these factors are represented by integers (1, 2), but are
more informative than integers because factors are self describing:
\texttt{"cement"}, \texttt{"earth"} is more descriptive than \texttt{1},
and \texttt{2}. Which one is ``earth''? You wouldn't be able to tell
just from the integer data. Factors, on the other hand, have this
information built in. It is particularly helpful when there are many
levels. It also makes renaming levels easier. Let's say we made a
mistake and need to recode ``cement'' to ``brick''. We can do this using
the \texttt{fct\_recode()} function from the \textbf{\texttt{forcats}}
package (included in the \textbf{\texttt{tidyverse}}) which provides
some extra tools to work with factors.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{levels}\NormalTok{(respondent\_floor\_type)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "earth"  "cement"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{respondent\_floor\_type }\OtherTok{\textless{}{-}} \FunctionTok{fct\_recode}\NormalTok{(respondent\_floor\_type, }\AttributeTok{brick =} \StringTok{"cement"}\NormalTok{)}

\DocumentationTok{\#\# as an alternative, we could change the "cement" level directly using the}
\DocumentationTok{\#\# levels() function, but we have to remember that "cement" is the second level}
\CommentTok{\# levels(respondent\_floor\_type)[2] \textless{}{-} "brick"}

\FunctionTok{levels}\NormalTok{(respondent\_floor\_type)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "earth" "brick"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{respondent\_floor\_type}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] earth brick brick earth
Levels: earth brick
\end{verbatim}

So far, your factor is unordered, like a nominal variable. R does not
know the difference between a nominal and an ordinal variable. You make
your factor an ordered factor by using the \texttt{ordered=TRUE} option
inside your factor function. Note how the reported levels changed from
the unordered factor above to the ordered version below. Ordered levels
use the less than sign \texttt{\textless{}} to denote level ranking.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{respondent\_floor\_type\_ordered }\OtherTok{\textless{}{-}} \FunctionTok{factor}\NormalTok{(respondent\_floor\_type, }
                                        \AttributeTok{ordered =} \ConstantTok{TRUE}\NormalTok{)}

\NormalTok{respondent\_floor\_type\_ordered }\CommentTok{\# after setting as ordered factor}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] earth brick brick earth
Levels: earth < brick
\end{verbatim}

\subsection{Converting factors}\label{converting-factors}

If you need to convert a factor to a character vector, you use
\texttt{as.character(x)}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as.character}\NormalTok{(respondent\_floor\_type)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "earth" "brick" "brick" "earth"
\end{verbatim}

Converting factors where the levels appear as numbers (such as
concentration levels, or years) to a numeric vector is a little
trickier. The \texttt{as.numeric()} function returns the index values of
the factor, not its levels, so it will result in an entirely new (and
unwanted in this case) set of numbers. One method to avoid this is to
convert factors to characters, and then to numbers. Another method is to
use the \texttt{levels()} function. Compare:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{year\_fct }\OtherTok{\textless{}{-}} \FunctionTok{factor}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{1990}\NormalTok{, }\DecValTok{1983}\NormalTok{, }\DecValTok{1977}\NormalTok{, }\DecValTok{1998}\NormalTok{, }\DecValTok{1990}\NormalTok{))}

\FunctionTok{as.numeric}\NormalTok{(year\_fct)                     }\CommentTok{\# Wrong! And there is no warning...}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 3 2 1 4 3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as.numeric}\NormalTok{(}\FunctionTok{as.character}\NormalTok{(year\_fct))       }\CommentTok{\# Works...}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 1990 1983 1977 1998 1990
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as.numeric}\NormalTok{(}\FunctionTok{levels}\NormalTok{(year\_fct))[year\_fct]   }\CommentTok{\# The recommended way.}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 1990 1983 1977 1998 1990
\end{verbatim}

Notice that in the recommended \texttt{levels()} approach, three
important steps occur:

\begin{itemize}
\tightlist
\item
  We obtain all the factor levels using \texttt{levels(year\_fct)}
\item
  We convert these levels to numeric values using
  \texttt{as.numeric(levels(year\_fct))}
\item
  We then access these numeric values using the underlying integers of
  the vector \texttt{year\_fct} inside the square brackets
\end{itemize}

\subsection{Renaming factors}\label{renaming-factors}

When your data is stored as a factor, you can use the \texttt{plot()}
function to get a quick glance at the number of observations represented
by each factor level. Let's extract the \texttt{memb\_assoc} column from
our data frame, convert it into a factor, and use it to look at the
number of interview respondents who were or were not members of an
irrigation association:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# create a vector from the data frame column "memb\_assoc"}
\NormalTok{memb\_assoc }\OtherTok{\textless{}{-}}\NormalTok{ interviews}\SpecialCharTok{$}\NormalTok{memb\_assoc}

\DocumentationTok{\#\# convert it into a factor}
\NormalTok{memb\_assoc }\OtherTok{\textless{}{-}} \FunctionTok{as.factor}\NormalTok{(memb\_assoc)}

\DocumentationTok{\#\# let\textquotesingle{}s see what it looks like}
\NormalTok{memb\_assoc}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
  [1] <NA> yes  <NA> <NA> <NA> <NA> no   yes  no   no   <NA> yes  no   <NA> yes 
 [16] <NA> <NA> <NA> <NA> <NA> no   <NA> <NA> no   no   no   <NA> no   yes  <NA>
 [31] <NA> yes  no   yes  yes  yes  <NA> yes  <NA> yes  <NA> no   no   <NA> no  
 [46] no   yes  <NA> <NA> yes  <NA> no   yes  no   <NA> yes  no   no   <NA> no  
 [61] yes  <NA> <NA> <NA> no   yes  no   no   no   no   yes  <NA> no   yes  <NA>
 [76] <NA> yes  no   no   yes  no   no   yes  no   yes  no   no   <NA> yes  yes 
 [91] yes  yes  yes  no   no   no   no   yes  no   no   yes  yes  no   <NA> no  
[106] no   <NA> no   no   <NA> no   <NA> <NA> no   no   no   no   yes  no   no  
[121] no   no   no   no   no   no   no   no   no   yes  <NA>
Levels: no yes
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# bar plot of the number of interview respondents who were}
\DocumentationTok{\#\# members of irrigation association:}
\FunctionTok{plot}\NormalTok{(memb\_assoc)}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{02-starting-with-data_files/figure-pdf/factor-plot-default-order-1.pdf}}

Looking at the plot compared to the output of the vector, we can see
that in addition to ``no''s and ``yes''s, there are some respondents for
whom the information about whether they were part of an irrigation
association hasn't been recorded, and encoded as missing data. These
respondents do not appear on the plot. Let's encode them differently so
they can be counted and visualized in our plot.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Let\textquotesingle{}s recreate the vector from the data frame column "memb\_assoc"}
\NormalTok{memb\_assoc }\OtherTok{\textless{}{-}}\NormalTok{ interviews}\SpecialCharTok{$}\NormalTok{memb\_assoc}

\DocumentationTok{\#\# replace the missing data with "undetermined"}
\NormalTok{memb\_assoc[}\FunctionTok{is.na}\NormalTok{(memb\_assoc)] }\OtherTok{\textless{}{-}} \StringTok{"undetermined"}

\DocumentationTok{\#\# convert it into a factor}
\NormalTok{memb\_assoc }\OtherTok{\textless{}{-}} \FunctionTok{as.factor}\NormalTok{(memb\_assoc)}

\DocumentationTok{\#\# let\textquotesingle{}s see what it looks like}
\NormalTok{memb\_assoc}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
  [1] undetermined yes          undetermined undetermined undetermined
  [6] undetermined no           yes          no           no          
 [11] undetermined yes          no           undetermined yes         
 [16] undetermined undetermined undetermined undetermined undetermined
 [21] no           undetermined undetermined no           no          
 [26] no           undetermined no           yes          undetermined
 [31] undetermined yes          no           yes          yes         
 [36] yes          undetermined yes          undetermined yes         
 [41] undetermined no           no           undetermined no          
 [46] no           yes          undetermined undetermined yes         
 [51] undetermined no           yes          no           undetermined
 [56] yes          no           no           undetermined no          
 [61] yes          undetermined undetermined undetermined no          
 [66] yes          no           no           no           no          
 [71] yes          undetermined no           yes          undetermined
 [76] undetermined yes          no           no           yes         
 [81] no           no           yes          no           yes         
 [86] no           no           undetermined yes          yes         
 [91] yes          yes          yes          no           no          
 [96] no           no           yes          no           no          
[101] yes          yes          no           undetermined no          
[106] no           undetermined no           no           undetermined
[111] no           undetermined undetermined no           no          
[116] no           no           yes          no           no          
[121] no           no           no           no           no          
[126] no           no           no           no           yes         
[131] undetermined
Levels: no undetermined yes
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# bar plot of the number of interview respondents who were}
\DocumentationTok{\#\# members of irrigation association:}
\FunctionTok{plot}\NormalTok{(memb\_assoc)}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{02-starting-with-data_files/figure-pdf/factor-plot-reorder-1.pdf}}

\section{Exercise}\label{exercise-6}

\begin{itemize}
\item
  Rename the levels of the factor to have the first letter in uppercase:
  ``No'',``Undetermined'', and ``Yes''.
\item
  Now that we have renamed the factor level to ``Undetermined'', can you
  recreate the barplot such that ``Undetermined'' is last (after
  ``Yes'')?
\end{itemize}

\begin{solution}[Solution]
\leavevmode

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Rename levels.}
\NormalTok{memb\_assoc }\OtherTok{\textless{}{-}} \FunctionTok{fct\_recode}\NormalTok{(memb\_assoc, }\AttributeTok{No =} \StringTok{"no"}\NormalTok{,}
                         \AttributeTok{Undetermined =} \StringTok{"undetermined"}\NormalTok{, }\AttributeTok{Yes =} \StringTok{"yes"}\NormalTok{)}
\DocumentationTok{\#\# Reorder levels. Note we need to use the new level names.}
\NormalTok{memb\_assoc }\OtherTok{\textless{}{-}} \FunctionTok{factor}\NormalTok{(memb\_assoc, }\AttributeTok{levels =} \FunctionTok{c}\NormalTok{(}\StringTok{"No"}\NormalTok{, }\StringTok{"Yes"}\NormalTok{, }\StringTok{"Undetermined"}\NormalTok{))}
\FunctionTok{plot}\NormalTok{(memb\_assoc)}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{02-starting-with-data_files/figure-pdf/factor-plot-exercise-1.pdf}}

\end{solution}

\section{Formatting Dates}\label{formatting-dates}

One of the most common issues that new (and experienced!) R users have
is converting date and time information into a variable that is
appropriate and usable during analyses. A best practice for dealing with
date data is to ensure that each component of your date is available as
a separate variable. In our dataset, we have a column
\texttt{interview\_date} which contains information about the year,
month, and day that the interview was conducted. Let's convert those
dates into three separate columns.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str}\NormalTok{(interviews)}
\end{Highlighting}
\end{Shaded}

We are going to use the package \textbf{\texttt{lubridate}}, , which is
included in the \textbf{\texttt{tidyverse}} installation and should be
loaded by default. However, if we deal with older versions of tidyverse
(2022 and ealier), we can manually load it by typing
\texttt{library(lubridate)}.

If necessary, start by loading the required package:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(lubridate)}
\end{Highlighting}
\end{Shaded}

The lubridate function \texttt{ymd()} takes a vector representing year,
month, and day, and converts it to a \texttt{Date} vector. \texttt{Date}
is a class of data recognized by R as being a date and can be
manipulated as such. The argument that the function requires is
flexible, but, as a best practice, is a character vector formatted as
``YYYY-MM-DD''.

Let's extract our \texttt{interview\_date} column and inspect the
structure:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dates }\OtherTok{\textless{}{-}}\NormalTok{ interviews}\SpecialCharTok{$}\NormalTok{interview\_date}
\FunctionTok{str}\NormalTok{(dates)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 POSIXct[1:131], format: "2016-11-17" "2016-11-17" "2016-11-17" "2016-11-17" "2016-11-17" ...
\end{verbatim}

When we imported the data in R, \texttt{read\_csv()} recognized that
this column contained date information. We can now use the
\texttt{day()}, \texttt{month()} and \texttt{year()} functions to
extract this information from the date, and create new columns in our
data frame to store it:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews}\SpecialCharTok{$}\NormalTok{day }\OtherTok{\textless{}{-}} \FunctionTok{day}\NormalTok{(dates)}
\NormalTok{interviews}\SpecialCharTok{$}\NormalTok{month }\OtherTok{\textless{}{-}} \FunctionTok{month}\NormalTok{(dates)}
\NormalTok{interviews}\SpecialCharTok{$}\NormalTok{year }\OtherTok{\textless{}{-}} \FunctionTok{year}\NormalTok{(dates)}
\NormalTok{interviews}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 131 x 17
   key_ID village  interview_date      no_membrs years_liv respondent_wall_type
    <dbl> <chr>    <dttm>                  <dbl>     <dbl> <chr>               
 1      1 God      2016-11-17 00:00:00         3         4 muddaub             
 2      2 God      2016-11-17 00:00:00         7         9 muddaub             
 3      3 God      2016-11-17 00:00:00        10        15 burntbricks         
 4      4 God      2016-11-17 00:00:00         7         6 burntbricks         
 5      5 God      2016-11-17 00:00:00         7        40 burntbricks         
 6      6 God      2016-11-17 00:00:00         3         3 muddaub             
 7      7 God      2016-11-17 00:00:00         6        38 muddaub             
 8      8 Chirodzo 2016-11-16 00:00:00        12        70 burntbricks         
 9      9 Chirodzo 2016-11-16 00:00:00         8         6 burntbricks         
10     10 Chirodzo 2016-12-16 00:00:00        12        23 burntbricks         
# i 121 more rows
# i 11 more variables: rooms <dbl>, memb_assoc <chr>, affect_conflicts <chr>,
#   liv_count <dbl>, items_owned <chr>, no_meals <dbl>, months_lack_food <chr>,
#   instanceID <chr>, day <int>, month <dbl>, year <dbl>
\end{verbatim}

Notice the three new columns at the end of our data frame.

In our example above, the \texttt{interview\_date} column was read in
correctly as a \texttt{Date} variable but generally that is not the
case. Date columns are often read in as \texttt{character} variables and
one can use the \texttt{as\_date()} function to convert them to the
appropriate \texttt{Date/POSIXct}format.

Let's say we have a vector of dates in character format:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{char\_dates }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"7/31/2012"}\NormalTok{, }\StringTok{"8/9/2014"}\NormalTok{, }\StringTok{"4/30/2016"}\NormalTok{)}
\FunctionTok{str}\NormalTok{(char\_dates)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 chr [1:3] "7/31/2012" "8/9/2014" "4/30/2016"
\end{verbatim}

We can convert this vector to dates as :

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as\_date}\NormalTok{(char\_dates, }\AttributeTok{format =} \StringTok{"\%m/\%d/\%Y"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "2012-07-31" "2014-08-09" "2016-04-30"
\end{verbatim}

Argument \texttt{format} tells the function the order to parse the
characters and identify the month, day and year. The format above is the
equivalent of mm/dd/yyyy. A wrong format can lead to parsing errors or
incorrect results.

For example, observe what happens when we use a lower case y instead of
upper case Y for the year.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as\_date}\NormalTok{(char\_dates, }\AttributeTok{format =} \StringTok{"\%m/\%d/\%y"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Warning: 3 failed to parse.
\end{verbatim}

\begin{verbatim}
[1] NA NA NA
\end{verbatim}

Here, the \texttt{\%y} part of the format stands for a two-digit year
instead of a four-digit year, and this leads to parsing errors.

Or in the following example, observe what happens when the month and day
elements of the format are switched.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as\_date}\NormalTok{(char\_dates, }\AttributeTok{format =} \StringTok{"\%d/\%m/\%y"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Warning: 3 failed to parse.
\end{verbatim}

\begin{verbatim}
[1] NA NA NA
\end{verbatim}

Since there is no month numbered 30 or 31, the first and third dates
cannot be parsed.

We can also use functions \texttt{ymd()}, \texttt{mdy()} or
\texttt{dmy()} to convert character variables to date.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mdy}\NormalTok{(char\_dates)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "2012-07-31" "2014-08-09" "2016-04-30"
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Use read\_csv to read tabular data in R.
\item
  Use factors to represent categorical data in R.
\end{itemize}

\bookmarksetup{startatroot}

\chapter{data frame}\label{data-frame}

\bookmarksetup{startatroot}

\chapter{Data Frames}\label{data-frames}

Data Frames are data displayed in a format as a table.

Data Frames can have different types of data inside it. While the first
column can be character, the second and third can be numeric or logical.
However, each column should have the same type of data.

Use the data.frame() function to create a data frame:

Example \# Create a data frame

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Data\_Frame }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{ (}
  \AttributeTok{Training =} \FunctionTok{c}\NormalTok{(}\StringTok{"Strength"}\NormalTok{, }\StringTok{"Stamina"}\NormalTok{, }\StringTok{"Other"}\NormalTok{),}
  \AttributeTok{Pulse =} \FunctionTok{c}\NormalTok{(}\DecValTok{100}\NormalTok{, }\DecValTok{150}\NormalTok{, }\DecValTok{120}\NormalTok{),}
  \AttributeTok{Duration =} \FunctionTok{c}\NormalTok{(}\DecValTok{60}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{45}\NormalTok{)}
\NormalTok{)}
\CommentTok{\# Print the data frame}
\NormalTok{Data\_Frame}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
  Training Pulse Duration
1 Strength   100       60
2  Stamina   150       30
3    Other   120       45
\end{verbatim}

\bookmarksetup{startatroot}

\chapter{Summarize the Data}\label{summarize-the-data}

Use the summary() function to summarize the data from a Data Frame:

Example

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Data\_Frame }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{ (}
  \AttributeTok{Training =} \FunctionTok{c}\NormalTok{(}\StringTok{"Strength"}\NormalTok{, }\StringTok{"Stamina"}\NormalTok{, }\StringTok{"Other"}\NormalTok{),}
  \AttributeTok{Pulse =} \FunctionTok{c}\NormalTok{(}\DecValTok{100}\NormalTok{, }\DecValTok{150}\NormalTok{, }\DecValTok{120}\NormalTok{),}
  \AttributeTok{Duration =} \FunctionTok{c}\NormalTok{(}\DecValTok{60}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{45}\NormalTok{)}
\NormalTok{)}

\NormalTok{Data\_Frame}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
  Training Pulse Duration
1 Strength   100       60
2  Stamina   150       30
3    Other   120       45
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{summary}\NormalTok{(Data\_Frame)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
   Training             Pulse          Duration   
 Length:3           Min.   :100.0   Min.   :30.0  
 Class :character   1st Qu.:110.0   1st Qu.:37.5  
 Mode  :character   Median :120.0   Median :45.0  
                    Mean   :123.3   Mean   :45.0  
                    3rd Qu.:135.0   3rd Qu.:52.5  
                    Max.   :150.0   Max.   :60.0  
\end{verbatim}

You will learn more about the summary() function in the statistical part
of the R tutorial.

Access Items We can use single brackets {[} {]}, double brackets {[}{[}
{]}{]} or \$ to access columns from a data frame:

Example

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Data\_Frame }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{ (}
  \AttributeTok{Training =} \FunctionTok{c}\NormalTok{(}\StringTok{"Strength"}\NormalTok{, }\StringTok{"Stamina"}\NormalTok{, }\StringTok{"Other"}\NormalTok{),}
  \AttributeTok{Pulse =} \FunctionTok{c}\NormalTok{(}\DecValTok{100}\NormalTok{, }\DecValTok{150}\NormalTok{, }\DecValTok{120}\NormalTok{),}
  \AttributeTok{Duration =} \FunctionTok{c}\NormalTok{(}\DecValTok{60}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{45}\NormalTok{)}
\NormalTok{)}

\NormalTok{Data\_Frame[}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
  Training
1 Strength
2  Stamina
3    Other
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Data\_Frame[[}\StringTok{"Training"}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "Strength" "Stamina"  "Other"   
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Data\_Frame}\SpecialCharTok{$}\NormalTok{Training}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "Strength" "Stamina"  "Other"   
\end{verbatim}

Add Rows Use the rbind() function to add new rows in a Data Frame:

Example

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Data\_Frame }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{ (}
  \AttributeTok{Training =} \FunctionTok{c}\NormalTok{(}\StringTok{"Strength"}\NormalTok{, }\StringTok{"Stamina"}\NormalTok{, }\StringTok{"Other"}\NormalTok{),}
  \AttributeTok{Pulse =} \FunctionTok{c}\NormalTok{(}\DecValTok{100}\NormalTok{, }\DecValTok{150}\NormalTok{, }\DecValTok{120}\NormalTok{),}
  \AttributeTok{Duration =} \FunctionTok{c}\NormalTok{(}\DecValTok{60}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{45}\NormalTok{)}
\NormalTok{)}

\CommentTok{\# Add a new row}
\NormalTok{New\_row\_DF }\OtherTok{\textless{}{-}} \FunctionTok{rbind}\NormalTok{(Data\_Frame, }\FunctionTok{c}\NormalTok{(}\StringTok{"Strength"}\NormalTok{, }\DecValTok{110}\NormalTok{, }\DecValTok{110}\NormalTok{))}

\CommentTok{\# Print the new row}
\NormalTok{New\_row\_DF}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
  Training Pulse Duration
1 Strength   100       60
2  Stamina   150       30
3    Other   120       45
4 Strength   110      110
\end{verbatim}

Add Columns Use the cbind() function to add new columns in a Data Frame:

Example

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Data\_Frame }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{ (}
  \AttributeTok{Training =} \FunctionTok{c}\NormalTok{(}\StringTok{"Strength"}\NormalTok{, }\StringTok{"Stamina"}\NormalTok{, }\StringTok{"Other"}\NormalTok{),}
  \AttributeTok{Pulse =} \FunctionTok{c}\NormalTok{(}\DecValTok{100}\NormalTok{, }\DecValTok{150}\NormalTok{, }\DecValTok{120}\NormalTok{),}
  \AttributeTok{Duration =} \FunctionTok{c}\NormalTok{(}\DecValTok{60}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{45}\NormalTok{)}
\NormalTok{)}

\CommentTok{\# Add a new column}
\NormalTok{New\_col\_DF }\OtherTok{\textless{}{-}} \FunctionTok{cbind}\NormalTok{(Data\_Frame, }\AttributeTok{Steps =} \FunctionTok{c}\NormalTok{(}\DecValTok{1000}\NormalTok{, }\DecValTok{6000}\NormalTok{, }\DecValTok{2000}\NormalTok{))}

\CommentTok{\# Print the new column}
\NormalTok{New\_col\_DF}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
  Training Pulse Duration Steps
1 Strength   100       60  1000
2  Stamina   150       30  6000
3    Other   120       45  2000
\end{verbatim}

Remove Rows and Columns Use the c() function to remove rows and columns
in a Data Frame:

Example

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Data\_Frame }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{ (}
  \AttributeTok{Training =} \FunctionTok{c}\NormalTok{(}\StringTok{"Strength"}\NormalTok{, }\StringTok{"Stamina"}\NormalTok{, }\StringTok{"Other"}\NormalTok{),}
  \AttributeTok{Pulse =} \FunctionTok{c}\NormalTok{(}\DecValTok{100}\NormalTok{, }\DecValTok{150}\NormalTok{, }\DecValTok{120}\NormalTok{),}
  \AttributeTok{Duration =} \FunctionTok{c}\NormalTok{(}\DecValTok{60}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{45}\NormalTok{)}
\NormalTok{)}

\CommentTok{\# Remove the first row and column}
\NormalTok{Data\_Frame\_New }\OtherTok{\textless{}{-}}\NormalTok{ Data\_Frame[}\SpecialCharTok{{-}}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{), }\SpecialCharTok{{-}}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{)]}

\CommentTok{\# Print the new data frame}
\NormalTok{Data\_Frame\_New}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
  Pulse Duration
2   150       30
3   120       45
\end{verbatim}

Amount of Rows and Columns Use the dim() function to find the amount of
rows and columns in a Data Frame:

Example

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Data\_Frame }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{ (}
  \AttributeTok{Training =} \FunctionTok{c}\NormalTok{(}\StringTok{"Strength"}\NormalTok{, }\StringTok{"Stamina"}\NormalTok{, }\StringTok{"Other"}\NormalTok{),}
  \AttributeTok{Pulse =} \FunctionTok{c}\NormalTok{(}\DecValTok{100}\NormalTok{, }\DecValTok{150}\NormalTok{, }\DecValTok{120}\NormalTok{),}
  \AttributeTok{Duration =} \FunctionTok{c}\NormalTok{(}\DecValTok{60}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{45}\NormalTok{)}
\NormalTok{)}

\FunctionTok{dim}\NormalTok{(Data\_Frame)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 3 3
\end{verbatim}

You can also use the ncol() function to find the number of columns and
nrow() to find the number of rows:

Example

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Data\_Frame }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{ (}
  \AttributeTok{Training =} \FunctionTok{c}\NormalTok{(}\StringTok{"Strength"}\NormalTok{, }\StringTok{"Stamina"}\NormalTok{, }\StringTok{"Other"}\NormalTok{),}
  \AttributeTok{Pulse =} \FunctionTok{c}\NormalTok{(}\DecValTok{100}\NormalTok{, }\DecValTok{150}\NormalTok{, }\DecValTok{120}\NormalTok{),}
  \AttributeTok{Duration =} \FunctionTok{c}\NormalTok{(}\DecValTok{60}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{45}\NormalTok{)}
\NormalTok{)}

\FunctionTok{ncol}\NormalTok{(Data\_Frame)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{nrow}\NormalTok{(Data\_Frame)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 3
\end{verbatim}

Data Frame Length Use the length() function to find the number of
columns in a Data Frame (similar to ncol()):

Example

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Data\_Frame }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{ (}
  \AttributeTok{Training =} \FunctionTok{c}\NormalTok{(}\StringTok{"Strength"}\NormalTok{, }\StringTok{"Stamina"}\NormalTok{, }\StringTok{"Other"}\NormalTok{),}
  \AttributeTok{Pulse =} \FunctionTok{c}\NormalTok{(}\DecValTok{100}\NormalTok{, }\DecValTok{150}\NormalTok{, }\DecValTok{120}\NormalTok{),}
  \AttributeTok{Duration =} \FunctionTok{c}\NormalTok{(}\DecValTok{60}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{45}\NormalTok{)}
\NormalTok{)}

\FunctionTok{length}\NormalTok{(Data\_Frame)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 3
\end{verbatim}

Combining Data Frames Use the rbind() function to combine two or more
data frames in R vertically:

Example

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Data\_Frame1 }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{ (}
  \AttributeTok{Training =} \FunctionTok{c}\NormalTok{(}\StringTok{"Strength"}\NormalTok{, }\StringTok{"Stamina"}\NormalTok{, }\StringTok{"Other"}\NormalTok{),}
  \AttributeTok{Pulse =} \FunctionTok{c}\NormalTok{(}\DecValTok{100}\NormalTok{, }\DecValTok{150}\NormalTok{, }\DecValTok{120}\NormalTok{),}
  \AttributeTok{Duration =} \FunctionTok{c}\NormalTok{(}\DecValTok{60}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{45}\NormalTok{)}
\NormalTok{)}

\NormalTok{Data\_Frame2 }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{ (}
  \AttributeTok{Training =} \FunctionTok{c}\NormalTok{(}\StringTok{"Stamina"}\NormalTok{, }\StringTok{"Stamina"}\NormalTok{, }\StringTok{"Strength"}\NormalTok{),}
  \AttributeTok{Pulse =} \FunctionTok{c}\NormalTok{(}\DecValTok{140}\NormalTok{, }\DecValTok{150}\NormalTok{, }\DecValTok{160}\NormalTok{),}
  \AttributeTok{Duration =} \FunctionTok{c}\NormalTok{(}\DecValTok{30}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{20}\NormalTok{)}
\NormalTok{)}

\NormalTok{New\_Data\_Frame }\OtherTok{\textless{}{-}} \FunctionTok{rbind}\NormalTok{(Data\_Frame1, Data\_Frame2)}
\NormalTok{New\_Data\_Frame}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
  Training Pulse Duration
1 Strength   100       60
2  Stamina   150       30
3    Other   120       45
4  Stamina   140       30
5  Stamina   150       30
6 Strength   160       20
\end{verbatim}

And use the cbind() function to combine two or more data frames in R
horizontally:

Example

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Data\_Frame3 }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{ (}
  \AttributeTok{Training =} \FunctionTok{c}\NormalTok{(}\StringTok{"Strength"}\NormalTok{, }\StringTok{"Stamina"}\NormalTok{, }\StringTok{"Other"}\NormalTok{),}
  \AttributeTok{Pulse =} \FunctionTok{c}\NormalTok{(}\DecValTok{100}\NormalTok{, }\DecValTok{150}\NormalTok{, }\DecValTok{120}\NormalTok{),}
  \AttributeTok{Duration =} \FunctionTok{c}\NormalTok{(}\DecValTok{60}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{45}\NormalTok{)}
\NormalTok{)}

\NormalTok{Data\_Frame4 }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{ (}
  \AttributeTok{Steps =} \FunctionTok{c}\NormalTok{(}\DecValTok{3000}\NormalTok{, }\DecValTok{6000}\NormalTok{, }\DecValTok{2000}\NormalTok{),}
  \AttributeTok{Calories =} \FunctionTok{c}\NormalTok{(}\DecValTok{300}\NormalTok{, }\DecValTok{400}\NormalTok{, }\DecValTok{300}\NormalTok{)}
\NormalTok{)}

\NormalTok{New\_Data\_Frame1 }\OtherTok{\textless{}{-}} \FunctionTok{cbind}\NormalTok{(Data\_Frame3, Data\_Frame4)}
\NormalTok{New\_Data\_Frame1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
  Training Pulse Duration Steps Calories
1 Strength   100       60  3000      300
2  Stamina   150       30  6000      400
3    Other   120       45  2000      300
\end{verbatim}

\bookmarksetup{startatroot}

\chapter{data in R}\label{data-in-r}

\bookmarksetup{startatroot}

\chapter{Data types}\label{data-types}

In any programming language there are some basic types of data; numeric,
character, integer, and logical.

\section{Numeric data type}\label{numeric-data-type}

A numeric type of data consists the whole number and also number with
decimal. In other words we can say a numeric types data consists a
numeric with decimal. for example

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{,}\FloatTok{2.3}\NormalTok{,}\FloatTok{5.7}\NormalTok{,}\FloatTok{8.9}\NormalTok{,}\DecValTok{0}\NormalTok{,}\DecValTok{78}\NormalTok{,}\DecValTok{80}\NormalTok{)}\OtherTok{{-}\textgreater{}}\NormalTok{num}
\NormalTok{num}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1]  2.0  3.0  2.3  5.7  8.9  0.0 78.0 80.0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(num)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "numeric"
\end{verbatim}

\section{Integer data type}\label{integer-data-type}

An integer type of data consists only the whole number. Or we can say an
integer type of data having number without decimal

\section{Character data type}\label{character-data-type}

A character type of data represented a alphabetic string values. A
special type of character string is ``factor'' which is likely in an
order.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{,}\StringTok{"hello"}\NormalTok{,}\StringTok{"B"}\NormalTok{,}\StringTok{"world"}\NormalTok{)}\OtherTok{{-}\textgreater{}}\NormalTok{chr}
\NormalTok{chr}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "a"     "hello" "B"     "world"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(chr)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "character"
\end{verbatim}

\section{Logical data type}\label{logical-data-type}

A logical type of data consists the value either True or False.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{c}\NormalTok{(}\ConstantTok{TRUE}\NormalTok{,}\ConstantTok{FALSE}\NormalTok{)}\OtherTok{{-}\textgreater{}}\NormalTok{logi}
\NormalTok{logi}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1]  TRUE FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(logi)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "logical"
\end{verbatim}

Note: You can also specify the class of any vector or variable using

\texttt{as.numeric()} for numeric type of data \texttt{as.character} for
character type of data \texttt{as.factor}\\
\texttt{as.logical}

\bookmarksetup{startatroot}

\chapter{Data Structure}\label{data-structure}

A data structure is a particular way of organizing data in a computer so
that it can be used effectively. Data structures are known to make data
accessing and operations easier. They are also selected or designed to
be used with different algorithms.

In other words a data structure is essentially a way to organize data in
a system to facilitate effective usage of the same. The whole idea is to
reduce the complexities of space and time in various tasks.

While using a programming language, different variables are essential to
store different data. These variables are reserved in a memory location
for storing values. Once a variable is created, some area in the memory
is reserved.

Data structures are the objects that are manipulated regularly in R.
They are used to store data in an organized fashion to make data
manipulation and other data operations more efficient. R has many data
structures. The following section will discuss them in detail.

\section{Vector}\label{vector}

A vector is an ordered collection of basic data types of a given length.
The only key thing here is all the elements of a vector must be of the
identical data type e.g homogeneous data structures. Vectors are
one-dimensional data structures.

Vector is one of the basic data structures in R. It is homogeneous,
which means that it only contains elements of the same data type. Data
types can be numeric, integer, character, complex, or logical.

Vectors are created by using the \texttt{c()} function. Coercion takes
place in a vector, from bottom to top, if the elements passed are of
different data types, from logical to integer to double to character.

The \texttt{class()} function is used to check the class of the vector.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Vectors(ordered collection of same data type)}
\NormalTok{X }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{8}\NormalTok{)}
\NormalTok{X}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 1 3 5 7 8
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Vec1 }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{44}\NormalTok{, }\DecValTok{25}\NormalTok{, }\DecValTok{64}\NormalTok{, }\DecValTok{96}\NormalTok{, }\DecValTok{30}\NormalTok{)}
\NormalTok{Vec1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 44 25 64 96 30
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Vec2 }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\ConstantTok{FALSE}\NormalTok{, }\FloatTok{9.8}\NormalTok{, }\StringTok{"hello world"}\NormalTok{)}
\NormalTok{Vec2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "1"           "FALSE"       "9.8"         "hello world"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(X)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "numeric"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(Vec1)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "numeric"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(Vec2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "character"
\end{verbatim}

Elements of a vector can be accessed by using their respective indexes.
{[} {]} brackets are used to specify indexes of the elements to be
accessed. For example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"Jan"}\NormalTok{,}\StringTok{"Feb"}\NormalTok{,}\StringTok{"March"}\NormalTok{,}\StringTok{"Apr"}\NormalTok{,}\StringTok{"May"}\NormalTok{,}\StringTok{"June"}\NormalTok{,}\StringTok{"July"}\NormalTok{)}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "Jan"   "Feb"   "March" "Apr"   "May"   "June"  "July" 
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y }\OtherTok{\textless{}{-}}\NormalTok{ x[}\FunctionTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{7}\NormalTok{)]}
\NormalTok{y}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "March" "Feb"   "July" 
\end{verbatim}

\subsection{Vector Arithmetic}\label{vector-arithmetic}

You can perform addition, subtraction, multiplication, and division on
the vectors having the same number of elements in the following ways:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v1 }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{4}\NormalTok{,}\DecValTok{6}\NormalTok{,}\DecValTok{7}\NormalTok{,}\DecValTok{31}\NormalTok{,}\DecValTok{45}\NormalTok{)}
\NormalTok{v1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1]  4  6  7 31 45
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v2 }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{54}\NormalTok{,}\DecValTok{1}\NormalTok{,}\DecValTok{10}\NormalTok{,}\DecValTok{86}\NormalTok{,}\DecValTok{14}\NormalTok{,}\DecValTok{57}\NormalTok{)}
\NormalTok{v2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 54  1 10 86 14 57
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{addv }\OtherTok{\textless{}{-}}\NormalTok{ v1}\SpecialCharTok{+}\NormalTok{v2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Warning in v1 + v2: longer object length is not a multiple of shorter object
length
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{addv}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1]  58   7  17 117  59  61
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{subv }\OtherTok{\textless{}{-}}\NormalTok{ v1}\SpecialCharTok{{-}}\NormalTok{v2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Warning in v1 - v2: longer object length is not a multiple of shorter object
length
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{subv}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] -50   5  -3 -55  31 -53
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{multiv }\OtherTok{\textless{}{-}}\NormalTok{ v1}\SpecialCharTok{*}\NormalTok{v2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Warning in v1 * v2: longer object length is not a multiple of shorter object
length
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{multiv}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1]  216    6   70 2666  630  228
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diviv }\OtherTok{\textless{}{-}}\NormalTok{ v1}\SpecialCharTok{/}\NormalTok{v2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Warning in v1/v2: longer object length is not a multiple of shorter object
length
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diviv}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 0.07407407 6.00000000 0.70000000 0.36046512 3.21428571 0.07017544
\end{verbatim}

\subsection{Sorting a Vector}\label{sorting-a-vector}

You can sort the elements of a vector by using the sort() function in
the following way:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{4}\NormalTok{,}\DecValTok{78}\NormalTok{,}\SpecialCharTok{{-}}\DecValTok{45}\NormalTok{,}\DecValTok{6}\NormalTok{,}\DecValTok{89}\NormalTok{,}\DecValTok{678}\NormalTok{)}
\NormalTok{sortv }\OtherTok{\textless{}{-}} \FunctionTok{sort}\NormalTok{(v)}
\NormalTok{sortv}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] -45   4   6  78  89 678
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#Sort the elements in the reverse order}
\NormalTok{revsortv }\OtherTok{\textless{}{-}} \FunctionTok{sort}\NormalTok{(v, }\AttributeTok{decreasing =} \ConstantTok{TRUE}\NormalTok{)}
\NormalTok{revsortv}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 678  89  78   6   4 -45
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#Sorting character vectors}
\NormalTok{v }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"Jan"}\NormalTok{,}\StringTok{"Feb"}\NormalTok{,}\StringTok{"March"}\NormalTok{,}\StringTok{"April"}\NormalTok{)}
\NormalTok{sortv }\OtherTok{\textless{}{-}} \FunctionTok{sort}\NormalTok{(v)}
\NormalTok{sortv }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "April" "Feb"   "Jan"   "March"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#Sorting character vectors in reverse order}
\NormalTok{revsortv }\OtherTok{\textless{}{-}} \FunctionTok{sort}\NormalTok{(v, }\AttributeTok{decreasing =} \ConstantTok{TRUE}\NormalTok{)}
\NormalTok{revsortv}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "March" "Jan"   "Feb"   "April"
\end{verbatim}

\section{Lists}\label{lists}

A list is a generic object consisting of an ordered collection of
objects. Lists are heterogeneous data structures. These are also
one-dimensional data structures. A list can be a list of vectors, list
of matrices, a list of characters and a list of functions and so on.

A list is a non-homogeneous data structure, which implies that it can
contain elements of different data types. It accepts numbers,
characters, lists, and even matrices and functions inside it. It is
created by using the list() function.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# The first attributes is a numeric vector containing the IDs which is created using the \textquotesingle{}c\textquotesingle{} command here}
\NormalTok{Id }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{)}
 
\CommentTok{\# The second attribute is the name which is created using this line of code here which is the character vector}
\NormalTok{Name }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\StringTok{"Debi"}\NormalTok{, }\StringTok{"Sandeep"}\NormalTok{, }\StringTok{"Subham"}\NormalTok{, }\StringTok{"Shiba"}\NormalTok{)}
 
\CommentTok{\# The third attribute is the number of which is a single numeric variable.}
\NormalTok{number }\OtherTok{=} \DecValTok{4}
 
\CommentTok{\# We can combine all these three different data types into a list which can be done using a list command}
\NormalTok{List }\OtherTok{=} \FunctionTok{list}\NormalTok{(Id, Name, number)}
\NormalTok{List}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[[1]]
[1] 1 2 3 4

[[2]]
[1] "Debi"    "Sandeep" "Subham"  "Shiba"  

[[3]]
[1] 4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{list1}\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}\StringTok{"Sam"}\NormalTok{, }\StringTok{"Green"}\NormalTok{, }\FunctionTok{c}\NormalTok{(}\DecValTok{8}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{67}\NormalTok{), }\ConstantTok{TRUE}\NormalTok{, }\FloatTok{51.99}\NormalTok{, }\FloatTok{11.78}\NormalTok{,}\ConstantTok{FALSE}\NormalTok{)}
\NormalTok{list1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[[1]]
[1] "Sam"

[[2]]
[1] "Green"

[[3]]
[1]  8  2 67

[[4]]
[1] TRUE

[[5]]
[1] 51.99

[[6]]
[1] 11.78

[[7]]
[1] FALSE
\end{verbatim}

\section{Accessing the Elements of a
List}\label{accessing-the-elements-of-a-list}

The elements of a list can be accessed by using the indices of those
elements.

For example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{list2 }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}\FunctionTok{matrix}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{,}\DecValTok{9}\NormalTok{,}\DecValTok{5}\NormalTok{,}\DecValTok{1}\NormalTok{,}\SpecialCharTok{{-}}\DecValTok{2}\NormalTok{,}\DecValTok{8}\NormalTok{), }\AttributeTok{nrow =} \DecValTok{2}\NormalTok{), }\FunctionTok{c}\NormalTok{(}\StringTok{"Jan"}\NormalTok{,}\StringTok{"Feb"}\NormalTok{,}\StringTok{"Mar"}\NormalTok{), }\FunctionTok{list}\NormalTok{(}\DecValTok{3}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{5}\NormalTok{))}
\NormalTok{list2[}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[[1]]
     [,1] [,2] [,3]
[1,]    3    5   -2
[2,]    9    1    8
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{list2[}\DecValTok{2}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[[1]]
[1] "Jan" "Feb" "Mar"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{list2[}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[[1]]
[[1]][[1]]
[1] 3

[[1]][[2]]
[1] 4

[[1]][[3]]
[1] 5
\end{verbatim}

\section{Dataframes}\label{dataframes}

Dataframes are generic data objects of R which are used to store the
tabular data. Data frame is a two-dimensional structure, in which each
column contains values of one variable and each row contains one set of
values from each column.

A data frame has the following characteristics:

A data-frame must have column names and every row should have a unique
name. Each column must have the identical number of items. Each item in
a single column must be of the same data type. Different columns may
have different data types. The column names of a data frame should not
be empty. The row names of a data frame should be unique. The data
stored in a data frame can be a numeric, factor, or character type. To
create a data frame we use the data.frame() function.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\#A vector which is a character vector}
\NormalTok{Name }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\StringTok{"Amiya"}\NormalTok{, }\StringTok{"Raj"}\NormalTok{, }\StringTok{"Asish"}\NormalTok{)}
 
\CommentTok{\# A vector which is a character vector}
\NormalTok{Language }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\StringTok{"R"}\NormalTok{, }\StringTok{"Python"}\NormalTok{, }\StringTok{"Java"}\NormalTok{)}
 
\CommentTok{\# A vector which is a numeric vector}
\NormalTok{Age }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\DecValTok{22}\NormalTok{, }\DecValTok{25}\NormalTok{, }\DecValTok{45}\NormalTok{)}
 
\CommentTok{\# To create dataframe use data.frame command and then pass each of the vectors we have created as arguments to the function data.frame()}
\NormalTok{df }\OtherTok{=} \FunctionTok{data.frame}\NormalTok{(Name, Language, Age)}
\NormalTok{df}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
   Name Language Age
1 Amiya        R  22
2   Raj   Python  25
3 Asish     Java  45
\end{verbatim}

\section{Matrices}\label{matrices}

A matrix is a rectangular arrangement of numbers in rows and columns. In
a matrix, as we know rows are the ones that run horizontally and columns
are the ones that run vertically. Matrices are two-dimensional,
homogeneous data structures. Now, let's see how to create a matrix in R.
To create a matrix in R you need to use the function called matrix. The
arguments to this \texttt{matrix()} are the set of elements in the
vector. You have to pass how many numbers of rows and how many numbers
of columns you want to have in your matrix and this is the important
point you have to remember that by default, matrices are in column-wise
order.

The basic syntax to create a matrix is given below:

\texttt{matrix(data,\ nrow,\ ncol,\ byrow,\ dimnames)} where,
\texttt{data} = the input element of a matrix given as a vector.
\texttt{nrow} = the number of rows to be created. \texttt{ncol} = the
number of columns to be created. \texttt{byrow} = the row-wise
arrangement of the elements instead of column-wise \texttt{dimnames} =
the names of columns or rows to be created.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{A }\OtherTok{=} \FunctionTok{matrix}\NormalTok{(}
     \CommentTok{\# Taking sequence of elements}
    \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{9}\NormalTok{),}
     
    \CommentTok{\# No of rows and columns}
    \AttributeTok{nrow =} \DecValTok{3}\NormalTok{, }\AttributeTok{ncol =} \DecValTok{3}\NormalTok{, }
 
    \CommentTok{\# By default matrices are in column{-}wise order So this parameter decide how to arrange the matrix         }
    \AttributeTok{byrow =} \ConstantTok{TRUE}                            
\NormalTok{)}
\NormalTok{A}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    4    5    6
[3,]    7    8    9
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{M1 }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{9}\NormalTok{), }\AttributeTok{nrow =} \DecValTok{3}\NormalTok{, }\AttributeTok{ncol =}\DecValTok{3}\NormalTok{, }\AttributeTok{byrow=} \ConstantTok{TRUE}\NormalTok{)}
\NormalTok{M1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    4    5    6
[3,]    7    8    9
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{M2 }\OtherTok{\textless{}{-}}  \FunctionTok{matrix}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{9}\NormalTok{), }\AttributeTok{nrow =} \DecValTok{3}\NormalTok{, }\AttributeTok{ncol =}\DecValTok{3}\NormalTok{, }\AttributeTok{byrow=} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{M2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2] [,3]
[1,]    1    4    7
[2,]    2    5    8
[3,]    3    6    9
\end{verbatim}

By using row and column names, a matrix can be created as follows:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rownames }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\StringTok{"row1"}\NormalTok{, }\StringTok{"row2"}\NormalTok{, }\StringTok{"row3"}\NormalTok{)}
\NormalTok{colnames }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\StringTok{"col1"}\NormalTok{, }\StringTok{"col2"}\NormalTok{, }\StringTok{"col3"}\NormalTok{)}
\NormalTok{M3 }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{9}\NormalTok{), }\AttributeTok{nrow =} \DecValTok{3}\NormalTok{, }\AttributeTok{byrow =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{dimnames =} \FunctionTok{list}\NormalTok{(rownames, colnames))}
\NormalTok{M3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     col1 col2 col3
row1    1    2    3
row2    4    5    6
row3    7    8    9
\end{verbatim}

\subsection{Accessing the Elements of a
Matrix}\label{accessing-the-elements-of-a-matrix}

To access the elements of a matrix, row and column indices are used in
the following ways: For accessing the elements of the matrix M3 created
above, use the following syntax:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{M3[}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{] }\CommentTok{\# first argument represent row number and second argument represent column number}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{M3[}\DecValTok{3}\NormalTok{,}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 9
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{M3[}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 6
\end{verbatim}

\section{Arrays}\label{arrays}

Arrays are the R data objects which store the data in more than two
dimensions. Arrays are n-dimensional data structures. For example, if we
create an array of dimensions (2, 3, 3) then it creates 3 rectangular
matrices each with 2 rows and 3 columns. They are homogeneous data
structures.

Now, let's see how to create arrays in R. To create an array in R you
need to use the function called array(). The arguments to this array()
are the set of elements in vectors and you have to pass a vector
containing the dimensions of the array.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{A }\OtherTok{=} \FunctionTok{array}\NormalTok{(}
    \CommentTok{\# Taking sequence of elements}
    \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{8}\NormalTok{),}
 
    \CommentTok{\# Creating two rectangular matrices each with two rows and two columns}
    \AttributeTok{dim =} \FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{)                       }
\NormalTok{)}
\NormalTok{A}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
, , 1

     [,1] [,2]
[1,]    1    3
[2,]    2    4

, , 2

     [,1] [,2]
[1,]    5    7
[2,]    6    8
\end{verbatim}

\section{Factors}\label{factors-1}

Factors are the data objects which are used to categorize the data and
store it as levels. They are useful for storing categorical data. They
can store both strings and integers. They are useful to categorize
unique values in columns like \texttt{TRUE} or \texttt{FALSE}, or
\texttt{MALE} or \texttt{FEMALE}, etc.. They are useful in data analysis
for statistical modeling.

Factors can be created using the as.factor() function and they take
vectors as inputs. For example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fac }\OtherTok{=} \FunctionTok{factor}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"Male"}\NormalTok{, }\StringTok{"Female"}\NormalTok{, }\StringTok{"Male"}\NormalTok{,}
               \StringTok{"Male"}\NormalTok{, }\StringTok{"Female"}\NormalTok{, }\StringTok{"Male"}\NormalTok{, }\StringTok{"Female"}\NormalTok{))}
\NormalTok{fac }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] Male   Female Male   Male   Female Male   Female
Levels: Female Male
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{data }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"Male"}\NormalTok{,}\StringTok{"Female"}\NormalTok{,}\StringTok{"Male"}\NormalTok{,}\StringTok{"Child"}\NormalTok{,}\StringTok{"Child"}\NormalTok{,}\StringTok{"Male"}\NormalTok{,}\StringTok{"Female"}\NormalTok{,}\StringTok{"Female"}\NormalTok{)}
\NormalTok{data}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "Male"   "Female" "Male"   "Child"  "Child"  "Male"   "Female" "Female"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{factordata }\OtherTok{\textless{}{-}} \FunctionTok{as.factor}\NormalTok{(data)}
\NormalTok{factordata}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] Male   Female Male   Child  Child  Male   Female Female
Levels: Child Female Male
\end{verbatim}

Now, let's see how to create factors in R. To create a factor in R you
need to use the function called factor(). The argument to this factor()
is the vector.

\bookmarksetup{startatroot}

\chapter{Data Wrangling with dplyr}\label{data-wrangling-with-dplyr}

\begin{itemize}
\tightlist
\item
  This lesson works better if you have graphics demonstrating dplyr
  commands. You can modify
  \href{https://docs.google.com/presentation/d/1A9abypFdFp8urAe9z7GCMjFr4aPeIb8mZAtJA2F7H0w/edit\#slide=id.g652714585f_0_114}{this
  Google Slides deck} and use it for your workshop.
\item
  For this lesson make sure that learners are comfortable using pipes.
\item
  There is also sometimes some confusion on what the arguments of
  \texttt{group\_by} should be, and when to use \texttt{filter()} and
  \texttt{select()}.
\end{itemize}

\begin{itemize}
\tightlist
\item
  Describe the purpose of an R package and the \textbf{\texttt{dplyr}}
  package.
\item
  Select certain columns in a dataframe with the \textbf{\texttt{dplyr}}
  function \texttt{select}.
\item
  Select certain rows in a dataframe according to filtering conditions
  with the \textbf{\texttt{dplyr}} function \texttt{filter}.
\item
  Link the output of one \textbf{\texttt{dplyr}} function to the input
  of another function with the `pipe' operator
  \texttt{\%\textgreater{}\%}.
\item
  Add new columns to a dataframe that are functions of existing columns
  with \texttt{mutate}.
\item
  Use the split-apply-combine concept for data analysis.
\item
  Use \texttt{summarize}, \texttt{group\_by}, and \texttt{count} to
  split a dataframe into groups of observations, apply a summary
  statistics for each group, and then combine the results.
\end{itemize}

\begin{itemize}
\tightlist
\item
  How can I select specific rows and/or columns from a dataframe?
\item
  How can I combine multiple commands into a single command?
\item
  How can I create new columns or remove existing columns from a
  dataframe?
\end{itemize}

\textbf{\texttt{dplyr}} is a package for making tabular data wrangling
easier by using a limited set of functions that can be combined to
extract and summarize insights from your data.

Like \textbf{\texttt{readr}}, \textbf{\texttt{dplyr}} is a part of the
tidyverse. These packages were loaded in R's memory when we called
\texttt{library(tidyverse)} earlier.

\begin{tcolorbox}[enhanced jigsaw, opacityback=0, left=2mm, bottomrule=.15mm, toprule=.15mm, breakable, colback=white, arc=.35mm, colframe=quarto-callout-color-frame, rightrule=.15mm, leftrule=.75mm]

\vspace{-3mm}\textbf{Note}\vspace{3mm}

The packages in the tidyverse, namely \textbf{\texttt{dplyr}},
\textbf{\texttt{tidyr}} and \textbf{\texttt{ggplot2}} accept both the
British (e.g.~\emph{summarise}) and American (e.g.~\emph{summarize})
spelling variants of different function and option names. For this
lesson, we utilize the American spellings of different functions;
however, feel free to use the regional variant for where you are
teaching.

\end{tcolorbox}

\section{What is an R package?}\label{what-is-an-r-package}

The package \textbf{\texttt{dplyr}} provides easy tools for the most
common data wrangling tasks. It is built to work directly with
dataframes, with many common tasks optimized by being written in a
compiled language (C++) (not all R packages are written in R!).

There are also packages available for a wide range of tasks including
building plots (\textbf{\texttt{ggplot2}}, which we'll see later),
downloading data from the NCBI database, or performing statistical
analysis on your data set. Many packages such as these are housed on,
and downloadable from, the \textbf{C}omprehensive \textbf{R}
\textbf{A}rchive \textbf{N}etwork (CRAN) using
\texttt{install.packages}. This function makes the package accessible by
your R installation with the command \texttt{library()}, as you did with
\texttt{tidyverse} earlier.

To easily access the documentation for a package within R or RStudio,
use \texttt{help(package\ =\ "package\_name")}.

To learn more about \textbf{\texttt{dplyr}} after the workshop, you may
want to check out this
\href{https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-transformation.pdf}{handy
data transformation with \textbf{\texttt{dplyr}} cheatsheet}.

\begin{tcolorbox}[enhanced jigsaw, opacityback=0, left=2mm, bottomrule=.15mm, toprule=.15mm, breakable, colback=white, arc=.35mm, colframe=quarto-callout-color-frame, rightrule=.15mm, leftrule=.75mm]

\vspace{-3mm}\textbf{Note}\vspace{3mm}

There are alternatives to the \texttt{tidyverse} packages for data
wrangling, including the package
\href{https://rdatatable.gitlab.io/data.table/}{\texttt{data.table}}.
See this
\href{https://mgimond.github.io/rug_2019_12/Index.html}{comparison} for
example to get a sense of the differences between using \texttt{base},
\texttt{tidyverse}, and \texttt{data.table}.

\end{tcolorbox}

\section{\texorpdfstring{Learning
\textbf{\texttt{dplyr}}}{Learning dplyr}}\label{learning-dplyr}

To make sure everyone will use the same dataset for this lesson, we'll
read again the SAFI dataset that we downloaded earlier.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# load the tidyverse}
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{library}\NormalTok{(here)}

\NormalTok{interviews }\OtherTok{\textless{}{-}} \FunctionTok{read\_csv}\NormalTok{(}\FunctionTok{here}\NormalTok{(}\StringTok{"data"}\NormalTok{, }\StringTok{"SAFI\_clean.csv"}\NormalTok{), }\AttributeTok{na =} \StringTok{"NULL"}\NormalTok{)}

\DocumentationTok{\#\# inspect the data}
\NormalTok{interviews}

\DocumentationTok{\#\# preview the data}
\CommentTok{\# view(interviews)}
\end{Highlighting}
\end{Shaded}

We're going to learn some of the most common \textbf{\texttt{dplyr}}
functions:

\begin{itemize}
\tightlist
\item
  \texttt{select()}: subset columns
\item
  \texttt{filter()}: subset rows on conditions
\item
  \texttt{mutate()}: create new columns by using information from other
  columns
\item
  \texttt{group\_by()} and \texttt{summarize()}: create summary
  statistics on grouped data
\item
  \texttt{arrange()}: sort results
\item
  \texttt{count()}: count discrete values
\end{itemize}

\section{Selecting columns and filtering
rows}\label{selecting-columns-and-filtering-rows}

To select columns of a dataframe, use \texttt{select()}. The first
argument to this function is the dataframe (\texttt{interviews}), and
the subsequent arguments are the columns to keep, separated by commas.
Alternatively, if you are selecting columns adjacent to each other, you
can use a \texttt{:} to select a range of columns, read as ``select
columns from \_\_\_ to \_\_\_.'' You may have done something similar in
the past using subsetting. \texttt{select()} is essentially doing the
same thing as subsetting, using a package (\texttt{dplyr}) instead of
R's base functions.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# to select columns throughout the dataframe}
\FunctionTok{select}\NormalTok{(interviews, village, no\_membrs, months\_lack\_food)}
\CommentTok{\# to do the same thing with subsetting}
\NormalTok{interviews[}\FunctionTok{c}\NormalTok{(}\StringTok{"village"}\NormalTok{,}\StringTok{"no\_membrs"}\NormalTok{,}\StringTok{"months\_lack\_food"}\NormalTok{)]}
\CommentTok{\# to select a series of connected columns}
\FunctionTok{select}\NormalTok{(interviews, village}\SpecialCharTok{:}\NormalTok{respondent\_wall\_type)}
\end{Highlighting}
\end{Shaded}

To choose rows based on specific criteria, we can use the
\texttt{filter()} function. The argument after the dataframe is the
condition we want our final dataframe to adhere to (e.g.~village name is
Chirodzo):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# filters observations where village name is "Chirodzo"}
\FunctionTok{filter}\NormalTok{(interviews, village }\SpecialCharTok{==} \StringTok{"Chirodzo"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 39 x 14
   key_ID village  interview_date      no_membrs years_liv respondent_wall_type
    <dbl> <chr>    <dttm>                  <dbl>     <dbl> <chr>               
 1      8 Chirodzo 2016-11-16 00:00:00        12        70 burntbricks         
 2      9 Chirodzo 2016-11-16 00:00:00         8         6 burntbricks         
 3     10 Chirodzo 2016-12-16 00:00:00        12        23 burntbricks         
 4     34 Chirodzo 2016-11-17 00:00:00         8        18 burntbricks         
 5     35 Chirodzo 2016-11-17 00:00:00         5        45 muddaub             
 6     36 Chirodzo 2016-11-17 00:00:00         6        23 sunbricks           
 7     37 Chirodzo 2016-11-17 00:00:00         3         8 burntbricks         
 8     43 Chirodzo 2016-11-17 00:00:00         7        29 muddaub             
 9     44 Chirodzo 2016-11-17 00:00:00         2         6 muddaub             
10     45 Chirodzo 2016-11-17 00:00:00         9         7 muddaub             
# i 29 more rows
# i 8 more variables: rooms <dbl>, memb_assoc <chr>, affect_conflicts <chr>,
#   liv_count <dbl>, items_owned <chr>, no_meals <dbl>, months_lack_food <chr>,
#   instanceID <chr>
\end{verbatim}

You may also have noticed that the output from these call doesn't run
off the screen anymore. It's one of the advantages of \texttt{tbl\_df}
(also called tibble), the central data class in the tidyverse, compared
to normal dataframes in R.

We can also specify multiple conditions within the \texttt{filter()}
function. We can combine conditions using either ``and'' or ``or''
statements. In an ``and'' statement, an observation (row) must meet
\textbf{every} criteria to be included in the resulting dataframe. To
form ``and'' statements within dplyr, we can pass our desired conditions
as arguments in the \texttt{filter()} function, separated by commas:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# filters observations with "and" operator (comma)}
\CommentTok{\# output dataframe satisfies ALL specified conditions}
\FunctionTok{filter}\NormalTok{(interviews, village }\SpecialCharTok{==} \StringTok{"Chirodzo"}\NormalTok{,}
\NormalTok{                   rooms }\SpecialCharTok{\textgreater{}} \DecValTok{1}\NormalTok{,}
\NormalTok{                   no\_meals }\SpecialCharTok{\textgreater{}} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 10 x 14
   key_ID village  interview_date      no_membrs years_liv respondent_wall_type
    <dbl> <chr>    <dttm>                  <dbl>     <dbl> <chr>               
 1     10 Chirodzo 2016-12-16 00:00:00        12        23 burntbricks         
 2     49 Chirodzo 2016-11-16 00:00:00         6        26 burntbricks         
 3     52 Chirodzo 2016-11-16 00:00:00        11        15 burntbricks         
 4     56 Chirodzo 2016-11-16 00:00:00        12        23 burntbricks         
 5     65 Chirodzo 2016-11-16 00:00:00         8        20 burntbricks         
 6     66 Chirodzo 2016-11-16 00:00:00        10        37 burntbricks         
 7     67 Chirodzo 2016-11-16 00:00:00         5        31 burntbricks         
 8     68 Chirodzo 2016-11-16 00:00:00         8        52 burntbricks         
 9    199 Chirodzo 2017-06-04 00:00:00         7        17 burntbricks         
10    200 Chirodzo 2017-06-04 00:00:00         8        20 burntbricks         
# i 8 more variables: rooms <dbl>, memb_assoc <chr>, affect_conflicts <chr>,
#   liv_count <dbl>, items_owned <chr>, no_meals <dbl>, months_lack_food <chr>,
#   instanceID <chr>
\end{verbatim}

We can also form ``and'' statements with the \texttt{\&} operator
instead of commas:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# filters observations with "\&" logical operator}
\CommentTok{\# output dataframe satisfies ALL specified conditions}
\FunctionTok{filter}\NormalTok{(interviews, village }\SpecialCharTok{==} \StringTok{"Chirodzo"} \SpecialCharTok{\&}
\NormalTok{                   rooms }\SpecialCharTok{\textgreater{}} \DecValTok{1} \SpecialCharTok{\&}
\NormalTok{                   no\_meals }\SpecialCharTok{\textgreater{}} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 10 x 14
   key_ID village  interview_date      no_membrs years_liv respondent_wall_type
    <dbl> <chr>    <dttm>                  <dbl>     <dbl> <chr>               
 1     10 Chirodzo 2016-12-16 00:00:00        12        23 burntbricks         
 2     49 Chirodzo 2016-11-16 00:00:00         6        26 burntbricks         
 3     52 Chirodzo 2016-11-16 00:00:00        11        15 burntbricks         
 4     56 Chirodzo 2016-11-16 00:00:00        12        23 burntbricks         
 5     65 Chirodzo 2016-11-16 00:00:00         8        20 burntbricks         
 6     66 Chirodzo 2016-11-16 00:00:00        10        37 burntbricks         
 7     67 Chirodzo 2016-11-16 00:00:00         5        31 burntbricks         
 8     68 Chirodzo 2016-11-16 00:00:00         8        52 burntbricks         
 9    199 Chirodzo 2017-06-04 00:00:00         7        17 burntbricks         
10    200 Chirodzo 2017-06-04 00:00:00         8        20 burntbricks         
# i 8 more variables: rooms <dbl>, memb_assoc <chr>, affect_conflicts <chr>,
#   liv_count <dbl>, items_owned <chr>, no_meals <dbl>, months_lack_food <chr>,
#   instanceID <chr>
\end{verbatim}

In an ``or'' statement, observations must meet \emph{at least one} of
the specified conditions. To form ``or'' statements we use the logical
operator for ``or,'' which is the vertical bar (\textbar):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# filters observations with "|" logical operator}
\CommentTok{\# output dataframe satisfies AT LEAST ONE of the specified conditions}
\FunctionTok{filter}\NormalTok{(interviews, village }\SpecialCharTok{==} \StringTok{"Chirodzo"} \SpecialCharTok{|}\NormalTok{ village }\SpecialCharTok{==} \StringTok{"Ruaca"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 88 x 14
   key_ID village  interview_date      no_membrs years_liv respondent_wall_type
    <dbl> <chr>    <dttm>                  <dbl>     <dbl> <chr>               
 1      8 Chirodzo 2016-11-16 00:00:00        12        70 burntbricks         
 2      9 Chirodzo 2016-11-16 00:00:00         8         6 burntbricks         
 3     10 Chirodzo 2016-12-16 00:00:00        12        23 burntbricks         
 4     23 Ruaca    2016-11-21 00:00:00        10        20 burntbricks         
 5     24 Ruaca    2016-11-21 00:00:00         6         4 burntbricks         
 6     25 Ruaca    2016-11-21 00:00:00        11         6 burntbricks         
 7     26 Ruaca    2016-11-21 00:00:00         3        20 burntbricks         
 8     27 Ruaca    2016-11-21 00:00:00         7        36 burntbricks         
 9     28 Ruaca    2016-11-21 00:00:00         2         2 muddaub             
10     29 Ruaca    2016-11-21 00:00:00         7        10 burntbricks         
# i 78 more rows
# i 8 more variables: rooms <dbl>, memb_assoc <chr>, affect_conflicts <chr>,
#   liv_count <dbl>, items_owned <chr>, no_meals <dbl>, months_lack_food <chr>,
#   instanceID <chr>
\end{verbatim}

\section{Pipes}\label{pipes}

What if you want to select and filter at the same time? There are three
ways to do this: use intermediate steps, nested functions, or pipes.

With intermediate steps, you create a temporary dataframe and use that
as input to the next function, like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews2 }\OtherTok{\textless{}{-}} \FunctionTok{filter}\NormalTok{(interviews, village }\SpecialCharTok{==} \StringTok{"Chirodzo"}\NormalTok{)}
\NormalTok{interviews\_ch }\OtherTok{\textless{}{-}} \FunctionTok{select}\NormalTok{(interviews2, village}\SpecialCharTok{:}\NormalTok{respondent\_wall\_type)}
\end{Highlighting}
\end{Shaded}

This is readable, but can clutter up your workspace with lots of objects
that you have to name individually. With multiple steps, that can be
hard to keep track of.

You can also nest functions (i.e.~one function inside of another), like
this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews\_ch }\OtherTok{\textless{}{-}} \FunctionTok{select}\NormalTok{(}\FunctionTok{filter}\NormalTok{(interviews, village }\SpecialCharTok{==} \StringTok{"Chirodzo"}\NormalTok{),}
\NormalTok{                         village}\SpecialCharTok{:}\NormalTok{respondent\_wall\_type)}
\end{Highlighting}
\end{Shaded}

This is handy, but can be difficult to read if too many functions are
nested, as R evaluates the expression from the inside out (in this case,
filtering, then selecting).

The last option, \emph{pipes}, are a recent addition to R. Pipes let you
take the output of one function and send it directly to the next, which
is useful when you need to do many things to the same dataset. There are
two Pipes in R: 1) \texttt{\%\textgreater{}\%} (called magrittr pipe;
made available via the \textbf{\texttt{magrittr}} package, installed
automatically with \textbf{\texttt{dplyr}}) or 2)
\texttt{\textbar{}\textgreater{}} (called native R pipe and it comes
preinstalled with R v4.1.0 onwards). Both the pipes are, by and large,
function similarly with a few differences (For more information, check:
https://www.tidyverse.org/blog/2023/04/base-vs-magrittr-pipe/). The
choice of which pipe to be used can be changed in the Global settings in
R studio and once that is done, you can type the pipe with:

\begin{itemize}
\tightlist
\item
  Ctrl + Shift + M if you have a PC or Cmd + Shift + M if you have a
  Mac.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# the following example is run using magrittr pipe but the output will be same with the native pipe}
\NormalTok{interviews }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{filter}\NormalTok{(village }\SpecialCharTok{==} \StringTok{"Chirodzo"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{select}\NormalTok{(village}\SpecialCharTok{:}\NormalTok{respondent\_wall\_type)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 39 x 5
   village  interview_date      no_membrs years_liv respondent_wall_type
   <chr>    <dttm>                  <dbl>     <dbl> <chr>               
 1 Chirodzo 2016-11-16 00:00:00        12        70 burntbricks         
 2 Chirodzo 2016-11-16 00:00:00         8         6 burntbricks         
 3 Chirodzo 2016-12-16 00:00:00        12        23 burntbricks         
 4 Chirodzo 2016-11-17 00:00:00         8        18 burntbricks         
 5 Chirodzo 2016-11-17 00:00:00         5        45 muddaub             
 6 Chirodzo 2016-11-17 00:00:00         6        23 sunbricks           
 7 Chirodzo 2016-11-17 00:00:00         3         8 burntbricks         
 8 Chirodzo 2016-11-17 00:00:00         7        29 muddaub             
 9 Chirodzo 2016-11-17 00:00:00         2         6 muddaub             
10 Chirodzo 2016-11-17 00:00:00         9         7 muddaub             
# i 29 more rows
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#interviews |\textgreater{}}
\CommentTok{\#   filter(village == "Chirodzo") |\textgreater{}}
\CommentTok{\#   select(village:respondent\_wall\_type)}
\end{Highlighting}
\end{Shaded}

In the above code, we use the pipe to send the \texttt{interviews}
dataset first through \texttt{filter()} to keep rows where
\texttt{village} is ``Chirodzo'', then through \texttt{select()} to keep
only the columns from \texttt{village} to
\texttt{respondent\_wall\_type}. Since \texttt{\%\textgreater{}\%} takes
the object on its left and passes it as the first argument to the
function on its right, we don't need to explicitly include the dataframe
as an argument to the \texttt{filter()} and \texttt{select()} functions
any more.

Some may find it helpful to read the pipe like the word ``then''. For
instance, in the above example, we take the dataframe
\texttt{interviews}, \emph{then} we \texttt{filter} for rows with
\texttt{village\ ==\ "Chirodzo"}, \emph{then} we \texttt{select} columns
\texttt{village:respondent\_wall\_type}. The \textbf{\texttt{dplyr}}
functions by themselves are somewhat simple, but by combining them into
linear workflows with the pipe, we can accomplish more complex data
wrangling operations.

If we want to create a new object with this smaller version of the data,
we can assign it a new name:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews\_ch }\OtherTok{\textless{}{-}}\NormalTok{ interviews }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{filter}\NormalTok{(village }\SpecialCharTok{==} \StringTok{"Chirodzo"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{select}\NormalTok{(village}\SpecialCharTok{:}\NormalTok{respondent\_wall\_type)}

\NormalTok{interviews\_ch}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 39 x 5
   village  interview_date      no_membrs years_liv respondent_wall_type
   <chr>    <dttm>                  <dbl>     <dbl> <chr>               
 1 Chirodzo 2016-11-16 00:00:00        12        70 burntbricks         
 2 Chirodzo 2016-11-16 00:00:00         8         6 burntbricks         
 3 Chirodzo 2016-12-16 00:00:00        12        23 burntbricks         
 4 Chirodzo 2016-11-17 00:00:00         8        18 burntbricks         
 5 Chirodzo 2016-11-17 00:00:00         5        45 muddaub             
 6 Chirodzo 2016-11-17 00:00:00         6        23 sunbricks           
 7 Chirodzo 2016-11-17 00:00:00         3         8 burntbricks         
 8 Chirodzo 2016-11-17 00:00:00         7        29 muddaub             
 9 Chirodzo 2016-11-17 00:00:00         2         6 muddaub             
10 Chirodzo 2016-11-17 00:00:00         9         7 muddaub             
# i 29 more rows
\end{verbatim}

Note that the final dataframe (\texttt{interviews\_ch}) is the leftmost
part of this expression.

\section{Exercise}\label{exercise-7}

Using pipes, subset the \texttt{interviews} data to include interviews
where respondents were members of an irrigation association
(\texttt{memb\_assoc}) and retain only the columns
\texttt{affect\_conflicts}, \texttt{liv\_count}, and \texttt{no\_meals}.

\begin{solution}[Solution]
\leavevmode

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{filter}\NormalTok{(memb\_assoc }\SpecialCharTok{==} \StringTok{"yes"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{select}\NormalTok{(affect\_conflicts, liv\_count, no\_meals)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 33 x 3
   affect_conflicts liv_count no_meals
   <chr>                <dbl>    <dbl>
 1 once                     3        2
 2 never                    2        2
 3 never                    2        3
 4 once                     3        2
 5 frequently               1        3
 6 more_once                5        2
 7 more_once                3        2
 8 more_once                2        3
 9 once                     3        3
10 never                    3        3
# i 23 more rows
\end{verbatim}

\end{solution}

\section{Mutate}\label{mutate-1}

Frequently you'll want to create new columns based on the values in
existing columns, for example to do unit conversions, or to find the
ratio of values in two columns. For this we'll use \texttt{mutate()}.

We might be interested in the ratio of number of household members to
rooms used for sleeping (i.e.~avg number of people per room):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{mutate}\NormalTok{(}\AttributeTok{people\_per\_room =}\NormalTok{ no\_membrs }\SpecialCharTok{/}\NormalTok{ rooms)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 131 x 15
   key_ID village  interview_date      no_membrs years_liv respondent_wall_type
    <dbl> <chr>    <dttm>                  <dbl>     <dbl> <chr>               
 1      1 God      2016-11-17 00:00:00         3         4 muddaub             
 2      2 God      2016-11-17 00:00:00         7         9 muddaub             
 3      3 God      2016-11-17 00:00:00        10        15 burntbricks         
 4      4 God      2016-11-17 00:00:00         7         6 burntbricks         
 5      5 God      2016-11-17 00:00:00         7        40 burntbricks         
 6      6 God      2016-11-17 00:00:00         3         3 muddaub             
 7      7 God      2016-11-17 00:00:00         6        38 muddaub             
 8      8 Chirodzo 2016-11-16 00:00:00        12        70 burntbricks         
 9      9 Chirodzo 2016-11-16 00:00:00         8         6 burntbricks         
10     10 Chirodzo 2016-12-16 00:00:00        12        23 burntbricks         
# i 121 more rows
# i 9 more variables: rooms <dbl>, memb_assoc <chr>, affect_conflicts <chr>,
#   liv_count <dbl>, items_owned <chr>, no_meals <dbl>, months_lack_food <chr>,
#   instanceID <chr>, people_per_room <dbl>
\end{verbatim}

We may be interested in investigating whether being a member of an
irrigation association had any effect on the ratio of household members
to rooms. To look at this relationship, we will first remove data from
our dataset where the respondent didn't answer the question of whether
they were a member of an irrigation association. These cases are
recorded as ``NULL'' in the dataset.

To remove these cases, we could insert a \texttt{filter()} in the chain:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{filter}\NormalTok{(}\SpecialCharTok{!}\FunctionTok{is.na}\NormalTok{(memb\_assoc)) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{mutate}\NormalTok{(}\AttributeTok{people\_per\_room =}\NormalTok{ no\_membrs }\SpecialCharTok{/}\NormalTok{ rooms)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 92 x 15
   key_ID village  interview_date      no_membrs years_liv respondent_wall_type
    <dbl> <chr>    <dttm>                  <dbl>     <dbl> <chr>               
 1      2 God      2016-11-17 00:00:00         7         9 muddaub             
 2      7 God      2016-11-17 00:00:00         6        38 muddaub             
 3      8 Chirodzo 2016-11-16 00:00:00        12        70 burntbricks         
 4      9 Chirodzo 2016-11-16 00:00:00         8         6 burntbricks         
 5     10 Chirodzo 2016-12-16 00:00:00        12        23 burntbricks         
 6     12 God      2016-11-21 00:00:00         7        20 burntbricks         
 7     13 God      2016-11-21 00:00:00         6         8 burntbricks         
 8     15 God      2016-11-21 00:00:00         5        30 sunbricks           
 9     21 God      2016-11-21 00:00:00         8        20 burntbricks         
10     24 Ruaca    2016-11-21 00:00:00         6         4 burntbricks         
# i 82 more rows
# i 9 more variables: rooms <dbl>, memb_assoc <chr>, affect_conflicts <chr>,
#   liv_count <dbl>, items_owned <chr>, no_meals <dbl>, months_lack_food <chr>,
#   instanceID <chr>, people_per_room <dbl>
\end{verbatim}

The \texttt{!} symbol negates the result of the \texttt{is.na()}
function. Thus, if \texttt{is.na()} returns a value of \texttt{TRUE}
(because the \texttt{memb\_assoc} is missing), the \texttt{!} symbol
negates this and says we only want values of \texttt{FALSE}, where
\texttt{memb\_assoc} \textbf{is not} missing.

\section{Exercise}\label{exercise-8}

Create a new dataframe from the \texttt{interviews} data that meets the
following criteria: contains only the \texttt{village} column and a new
column called \texttt{total\_meals} containing a value that is equal to
the total number of meals served in the household per day on average
(\texttt{no\_membrs} times \texttt{no\_meals}). Only the rows where
\texttt{total\_meals} is greater than 20 should be shown in the final
dataframe.

\textbf{Hint}: think about how the commands should be ordered to produce
this data frame!

\begin{solution}[Solution]
\leavevmode

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews\_total\_meals }\OtherTok{\textless{}{-}}\NormalTok{ interviews }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{mutate}\NormalTok{(}\AttributeTok{total\_meals =}\NormalTok{ no\_membrs }\SpecialCharTok{*}\NormalTok{ no\_meals) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{filter}\NormalTok{(total\_meals }\SpecialCharTok{\textgreater{}} \DecValTok{20}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{select}\NormalTok{(village, total\_meals)}
\end{Highlighting}
\end{Shaded}

\end{solution}

\section{Split-apply-combine data analysis and the summarize()
function}\label{split-apply-combine-data-analysis-and-the-summarize-function}

Many data analysis tasks can be approached using the
\emph{split-apply-combine} paradigm: split the data into groups, apply
some analysis to each group, and then combine the results.
\textbf{\texttt{dplyr}} makes this very easy through the use of the
\texttt{group\_by()} function.

\subsection{\texorpdfstring{The \texttt{summarize()}
function}{The summarize() function}}\label{the-summarize-function}

\texttt{group\_by()} is often used together with \texttt{summarize()},
which collapses each group into a single-row summary of that group.
\texttt{group\_by()} takes as arguments the column names that contain
the \textbf{categorical} variables for which you want to calculate the
summary statistics. So to compute the average household size by village:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{group\_by}\NormalTok{(village) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{summarize}\NormalTok{(}\AttributeTok{mean\_no\_membrs =} \FunctionTok{mean}\NormalTok{(no\_membrs))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 3 x 2
  village  mean_no_membrs
  <chr>             <dbl>
1 Chirodzo           7.08
2 God                6.86
3 Ruaca              7.57
\end{verbatim}

You can also group by multiple columns:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{group\_by}\NormalTok{(village, memb\_assoc) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{summarize}\NormalTok{(}\AttributeTok{mean\_no\_membrs =} \FunctionTok{mean}\NormalTok{(no\_membrs))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
`summarise()` has grouped output by 'village'. You can override using the
`.groups` argument.
\end{verbatim}

\begin{verbatim}
# A tibble: 9 x 3
# Groups:   village [3]
  village  memb_assoc mean_no_membrs
  <chr>    <chr>               <dbl>
1 Chirodzo no                   8.06
2 Chirodzo yes                  7.82
3 Chirodzo <NA>                 5.08
4 God      no                   7.13
5 God      yes                  8   
6 God      <NA>                 6   
7 Ruaca    no                   7.18
8 Ruaca    yes                  9.5 
9 Ruaca    <NA>                 6.22
\end{verbatim}

Note that the output is a grouped tibble of nine rows by three columns
which is indicated by the by two first lines with the \texttt{\#}. To
obtain an ungrouped tibble, use the \texttt{ungroup} function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{group\_by}\NormalTok{(village, memb\_assoc) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{summarize}\NormalTok{(}\AttributeTok{mean\_no\_membrs =} \FunctionTok{mean}\NormalTok{(no\_membrs)) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{ungroup}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
`summarise()` has grouped output by 'village'. You can override using the
`.groups` argument.
\end{verbatim}

\begin{verbatim}
# A tibble: 9 x 3
  village  memb_assoc mean_no_membrs
  <chr>    <chr>               <dbl>
1 Chirodzo no                   8.06
2 Chirodzo yes                  7.82
3 Chirodzo <NA>                 5.08
4 God      no                   7.13
5 God      yes                  8   
6 God      <NA>                 6   
7 Ruaca    no                   7.18
8 Ruaca    yes                  9.5 
9 Ruaca    <NA>                 6.22
\end{verbatim}

Notice that the second line with the \texttt{\#} that previously
indicated the grouping has disappeared and we now only have a 9x3-tibble
without grouping. When grouping both by \texttt{village} and
\texttt{membr\_assoc}, we see rows in our table for respondents who did
not specify whether they were a member of an irrigation association. We
can exclude those data from our table using a filter step.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{filter}\NormalTok{(}\SpecialCharTok{!}\FunctionTok{is.na}\NormalTok{(memb\_assoc)) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{group\_by}\NormalTok{(village, memb\_assoc) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{summarize}\NormalTok{(}\AttributeTok{mean\_no\_membrs =} \FunctionTok{mean}\NormalTok{(no\_membrs))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
`summarise()` has grouped output by 'village'. You can override using the
`.groups` argument.
\end{verbatim}

\begin{verbatim}
# A tibble: 6 x 3
# Groups:   village [3]
  village  memb_assoc mean_no_membrs
  <chr>    <chr>               <dbl>
1 Chirodzo no                   8.06
2 Chirodzo yes                  7.82
3 God      no                   7.13
4 God      yes                  8   
5 Ruaca    no                   7.18
6 Ruaca    yes                  9.5 
\end{verbatim}

Once the data are grouped, you can also summarize multiple variables at
the same time (and not necessarily on the same variable). For instance,
we could add a column indicating the minimum household size for each
village for each group (members of an irrigation association vs not):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{filter}\NormalTok{(}\SpecialCharTok{!}\FunctionTok{is.na}\NormalTok{(memb\_assoc)) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{group\_by}\NormalTok{(village, memb\_assoc) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{summarize}\NormalTok{(}\AttributeTok{mean\_no\_membrs =} \FunctionTok{mean}\NormalTok{(no\_membrs),}
              \AttributeTok{min\_membrs =} \FunctionTok{min}\NormalTok{(no\_membrs))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
`summarise()` has grouped output by 'village'. You can override using the
`.groups` argument.
\end{verbatim}

\begin{verbatim}
# A tibble: 6 x 4
# Groups:   village [3]
  village  memb_assoc mean_no_membrs min_membrs
  <chr>    <chr>               <dbl>      <dbl>
1 Chirodzo no                   8.06          4
2 Chirodzo yes                  7.82          2
3 God      no                   7.13          3
4 God      yes                  8             5
5 Ruaca    no                   7.18          2
6 Ruaca    yes                  9.5           5
\end{verbatim}

It is sometimes useful to rearrange the result of a query to inspect the
values. For instance, we can sort on \texttt{min\_membrs} to put the
group with the smallest household first:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{filter}\NormalTok{(}\SpecialCharTok{!}\FunctionTok{is.na}\NormalTok{(memb\_assoc)) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{group\_by}\NormalTok{(village, memb\_assoc) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{summarize}\NormalTok{(}\AttributeTok{mean\_no\_membrs =} \FunctionTok{mean}\NormalTok{(no\_membrs),}
              \AttributeTok{min\_membrs =} \FunctionTok{min}\NormalTok{(no\_membrs)) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{arrange}\NormalTok{(min\_membrs)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
`summarise()` has grouped output by 'village'. You can override using the
`.groups` argument.
\end{verbatim}

\begin{verbatim}
# A tibble: 6 x 4
# Groups:   village [3]
  village  memb_assoc mean_no_membrs min_membrs
  <chr>    <chr>               <dbl>      <dbl>
1 Chirodzo yes                  7.82          2
2 Ruaca    no                   7.18          2
3 God      no                   7.13          3
4 Chirodzo no                   8.06          4
5 God      yes                  8             5
6 Ruaca    yes                  9.5           5
\end{verbatim}

To sort in descending order, we need to add the \texttt{desc()}
function. If we want to sort the results by decreasing order of minimum
household size:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{filter}\NormalTok{(}\SpecialCharTok{!}\FunctionTok{is.na}\NormalTok{(memb\_assoc)) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{group\_by}\NormalTok{(village, memb\_assoc) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{summarize}\NormalTok{(}\AttributeTok{mean\_no\_membrs =} \FunctionTok{mean}\NormalTok{(no\_membrs),}
              \AttributeTok{min\_membrs =} \FunctionTok{min}\NormalTok{(no\_membrs)) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{arrange}\NormalTok{(}\FunctionTok{desc}\NormalTok{(min\_membrs))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
`summarise()` has grouped output by 'village'. You can override using the
`.groups` argument.
\end{verbatim}

\begin{verbatim}
# A tibble: 6 x 4
# Groups:   village [3]
  village  memb_assoc mean_no_membrs min_membrs
  <chr>    <chr>               <dbl>      <dbl>
1 God      yes                  8             5
2 Ruaca    yes                  9.5           5
3 Chirodzo no                   8.06          4
4 God      no                   7.13          3
5 Chirodzo yes                  7.82          2
6 Ruaca    no                   7.18          2
\end{verbatim}

\subsection{Counting}\label{counting}

When working with data, we often want to know the number of observations
found for each factor or combination of factors. For this task,
\textbf{\texttt{dplyr}} provides \texttt{count()}. For example, if we
wanted to count the number of rows of data for each village, we would
do:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{count}\NormalTok{(village)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 3 x 2
  village      n
  <chr>    <int>
1 Chirodzo    39
2 God         43
3 Ruaca       49
\end{verbatim}

For convenience, \texttt{count()} provides the \texttt{sort} argument to
get results in decreasing order:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{count}\NormalTok{(village, }\AttributeTok{sort =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 3 x 2
  village      n
  <chr>    <int>
1 Ruaca       49
2 God         43
3 Chirodzo    39
\end{verbatim}

\section{Exercise}\label{exercise-9}

How many households in the survey have an average of two meals per day?
Three meals per day? Are there any other numbers of meals represented?

\begin{solution}[Solution]
\leavevmode

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews }\SpecialCharTok{\%\textgreater{}\%}
   \FunctionTok{count}\NormalTok{(no\_meals)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 2 x 2
  no_meals     n
     <dbl> <int>
1        2    52
2        3    79
\end{verbatim}

\end{solution}

Use \texttt{group\_by()} and \texttt{summarize()} to find the mean, min,
and max number of household members for each village. Also add the
number of observations (hint: see \texttt{?n}).

\begin{solution}[Solution]
\leavevmode

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(village) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarize}\NormalTok{(}
      \AttributeTok{mean\_no\_membrs =} \FunctionTok{mean}\NormalTok{(no\_membrs),}
      \AttributeTok{min\_no\_membrs =} \FunctionTok{min}\NormalTok{(no\_membrs),}
      \AttributeTok{max\_no\_membrs =} \FunctionTok{max}\NormalTok{(no\_membrs),}
      \AttributeTok{n =} \FunctionTok{n}\NormalTok{()}
\NormalTok{  )}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 3 x 5
  village  mean_no_membrs min_no_membrs max_no_membrs     n
  <chr>             <dbl>         <dbl>         <dbl> <int>
1 Chirodzo           7.08             2            12    39
2 God                6.86             3            15    43
3 Ruaca              7.57             2            19    49
\end{verbatim}

\end{solution}

What was the largest household interviewed in each month?

\begin{solution}[Solution]
\leavevmode

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# if not already included, add month, year, and day columns}
\FunctionTok{library}\NormalTok{(lubridate) }\CommentTok{\# load lubridate if not already loaded}
\NormalTok{interviews }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{mutate}\NormalTok{(}\AttributeTok{month =} \FunctionTok{month}\NormalTok{(interview\_date),}
           \AttributeTok{day =} \FunctionTok{day}\NormalTok{(interview\_date),}
           \AttributeTok{year =} \FunctionTok{year}\NormalTok{(interview\_date)) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{group\_by}\NormalTok{(year, month) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{summarize}\NormalTok{(}\AttributeTok{max\_no\_membrs =} \FunctionTok{max}\NormalTok{(no\_membrs))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
`summarise()` has grouped output by 'year'. You can override using the
`.groups` argument.
\end{verbatim}

\begin{verbatim}
# A tibble: 5 x 3
# Groups:   year [2]
   year month max_no_membrs
  <dbl> <dbl>         <dbl>
1  2016    11            19
2  2016    12            12
3  2017     4            17
4  2017     5            15
5  2017     6            15
\end{verbatim}

\end{solution}

\begin{itemize}
\tightlist
\item
  Use the \texttt{dplyr} package to manipulate dataframes.
\item
  Use \texttt{select()} to choose variables from a dataframe.
\item
  Use \texttt{filter()} to choose data based on values.
\item
  Use \texttt{group\_by()} and \texttt{summarize()} to work with subsets
  of data.
\item
  Use \texttt{mutate()} to create new variables.
\end{itemize}

\bookmarksetup{startatroot}

\chapter{Data Wrangling with tidyr}\label{data-wrangling-with-tidyr}

\begin{itemize}
\tightlist
\item
  Describe the concept of a wide and a long table format and for which
  purpose those formats are useful.
\item
  Describe the roles of variable names and their associated values when
  a table is reshaped.
\item
  Reshape a dataframe from long to wide format and back with the
  \texttt{pivot\_wider} and \texttt{pivot\_longer} commands from the
  \textbf{\texttt{tidyr}} package.
\item
  Export a dataframe to a csv file.
\end{itemize}

\begin{itemize}
\tightlist
\item
  How can I reformat a data frame to meet my needs?
\end{itemize}

\textbf{\texttt{dplyr}} pairs nicely with \textbf{\texttt{tidyr}} which
enables you to swiftly convert between different data formats (long
vs.~wide) for plotting and analysis. To learn more about
\textbf{\texttt{tidyr}} after the workshop, you may want to check out
this
\href{https://raw.githubusercontent.com/rstudio/cheatsheets/main/tidyr.pdf}{handy
data tidying with \textbf{\texttt{tidyr}} cheatsheet}.

To make sure everyone will use the same dataset for this lesson, we'll
read again the SAFI dataset that we downloaded earlier.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# load the tidyverse}
\FunctionTok{library}\NormalTok{(tidyverse)}
\FunctionTok{library}\NormalTok{(here)}

\NormalTok{interviews }\OtherTok{\textless{}{-}} \FunctionTok{read\_csv}\NormalTok{(}\FunctionTok{here}\NormalTok{(}\StringTok{"data"}\NormalTok{, }\StringTok{"SAFI\_clean.csv"}\NormalTok{), }\AttributeTok{na =} \StringTok{"NULL"}\NormalTok{)}

\DocumentationTok{\#\# inspect the data}
\NormalTok{interviews}

\DocumentationTok{\#\# preview the data}
\CommentTok{\# view(interviews)}
\end{Highlighting}
\end{Shaded}

\section{Reshaping with pivot\_wider() and
pivot\_longer()}\label{reshaping-with-pivot_wider-and-pivot_longer}

There are essentially three rules that define a ``tidy'' dataset:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Each variable has its own column
\item
  Each observation has its own row
\item
  Each value must have its own cell
\end{enumerate}

This graphic visually represents the three rules that define a ``tidy''
dataset:

\pandocbounded{\includegraphics[keepaspectratio]{fig/tidy-data-wickham.png}}
\emph{R for Data Science}, Wickham H and Grolemund G
(\url{https://r4ds.had.co.nz/index.html})  Wickham, Grolemund 2017 This
image is licenced under Attribution-NonCommercial-NoDerivs 3.0 United
States (CC-BY-NC-ND 3.0 US)

In this section we will explore how these rules are linked to the
different data formats researchers are often interested in: ``wide'' and
``long''. This tutorial will help you efficiently transform your data
shape regardless of original format. First we will explore qualities of
the \texttt{interviews} data and how they relate to these different
types of data formats.

\subsection{Long and wide data
formats}\label{long-and-wide-data-formats}

In the \texttt{interviews} data, each row contains the values of
variables associated with each record collected (each interview in the
villages). It is stated that the \texttt{key\_ID} was ``added to provide
a unique Id for each observation'' and the \texttt{instanceID} ``does
this as well but it is not as convenient to use.''

Once we have established that \texttt{key\_ID} and \texttt{instanceID}
are both unique we can use either variable as an identifier
corresponding to the 131 interview records.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{select}\NormalTok{(key\_ID) }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{distinct}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{count}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 1 x 1
      n
  <int>
1   131
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{select}\NormalTok{(instanceID) }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{distinct}\NormalTok{() }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{count}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 1 x 1
      n
  <int>
1   131
\end{verbatim}

As seen in the code below, for each interview date in each village no
\texttt{instanceID}s are the same. Thus, this format is what is called a
``long'' data format, where each observation occupies only one row in
the dataframe.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(village }\SpecialCharTok{==} \StringTok{"Chirodzo"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{select}\NormalTok{(key\_ID, village, interview\_date, instanceID) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{sample\_n}\NormalTok{(}\AttributeTok{size =} \DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 10 x 4
   key_ID village  interview_date      instanceID                               
    <dbl> <chr>    <dttm>              <chr>                                    
 1     44 Chirodzo 2016-11-17 00:00:00 uuid:f9fadf44-d040-4fca-86c1-2835f79c4952
 2     68 Chirodzo 2016-11-16 00:00:00 uuid:ef04b3eb-b47d-412e-9b09-4f5e08fc66f9
 3     60 Chirodzo 2016-11-16 00:00:00 uuid:85465caf-23e4-4283-bb72-a0ef30e30176
 4     43 Chirodzo 2016-11-17 00:00:00 uuid:b4dff49f-ef27-40e5-a9d1-acf287b47358
 5     45 Chirodzo 2016-11-17 00:00:00 uuid:e3554d22-35b1-4fb9-b386-dd5866ad5792
 6     64 Chirodzo 2016-11-16 00:00:00 uuid:28cfd718-bf62-4d90-8100-55fafbe45d06
 7     34 Chirodzo 2016-11-17 00:00:00 uuid:14c78c45-a7cc-4b2a-b765-17c82b43feb4
 8     47 Chirodzo 2016-11-17 00:00:00 uuid:2d0b1936-4f82-4ec3-a3b5-7c3c8cd6cc2b
 9    199 Chirodzo 2017-06-04 00:00:00 uuid:ffc83162-ff24-4a87-8709-eff17abc0b3b
10     63 Chirodzo 2016-11-16 00:00:00 uuid:86ed4328-7688-462f-aac7-d6518414526a
\end{verbatim}

We notice that the layout or format of the \texttt{interviews} data is
in a format that adheres to rules 1-3, where

\begin{itemize}
\tightlist
\item
  each column is a variable
\item
  each row is an observation
\item
  each value has its own cell
\end{itemize}

This is called a ``long'' data format. But, we notice that each column
represents a different variable. In the ``longest'' data format there
would only be three columns, one for the id variable, one for the
observed variable, and one for the observed value (of that variable).
This data format is quite unsightly and difficult to work with, so you
will rarely see it in use.

Alternatively, in a ``wide'' data format we see modifications to rule 1,
where each column no longer represents a single variable. Instead,
columns can represent different levels/values of a variable. For
instance, in some data you encounter the researchers may have chosen for
every survey date to be a different column.

These may sound like dramatically different data layouts, but there are
some tools that make transitions between these layouts much simpler than
you might think! The gif below shows how these two formats relate to
each other, and gives you an idea of how we can use R to shift from one
format to the other.

\pandocbounded{\includegraphics[keepaspectratio]{fig/tidyr-pivot_wider_longer.gif}}
Long and wide dataframe layouts mainly affect readability. You may find
that visually you may prefer the ``wide'' format, since you can see more
of the data on the screen. However, all of the R functions we have used
thus far expect for your data to be in a ``long'' data format. This is
because the long format is more machine readable and is closer to the
formatting of databases.

\subsection{Questions which warrant different data
formats}\label{questions-which-warrant-different-data-formats}

In interviews, each row contains the values of variables associated with
each record (the unit), values such as the village of the respondent,
the number of household members, or the type of wall their house had.
This format allows for us to make comparisons across individual surveys,
but what if we wanted to look at differences in households grouped by
different types of items owned?

To facilitate this comparison we would need to create a new table where
each row (the unit) was comprised of values of variables associated with
items owned (i.e., \texttt{items\_owned}). In practical terms this means
the values of the items in \texttt{items\_owned} (e.g.~bicycle, radio,
table, etc.) would become the names of column variables and the cells
would contain values of \texttt{TRUE} or \texttt{FALSE}, for whether
that household had that item.

Once we we've created this new table, we can explore the relationship
within and between villages. The key point here is that we are still
following a tidy data structure, but we have \textbf{reshaped} the data
according to the observations of interest.

Alternatively, if the interview dates were spread across multiple
columns, and we were interested in visualizing, within each village, how
irrigation conflicts have changed over time. This would require for the
interview date to be included in a single column rather than spread
across multiple columns. Thus, we would need to transform the column
names into values of a variable.

We can do both of these transformations with two \texttt{tidyr}
functions, \texttt{pivot\_wider()} and \texttt{pivot\_longer()}.

\section{Pivoting wider}\label{pivoting-wider}

\texttt{pivot\_wider()} takes three principal arguments:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  the data
\item
  the \emph{names\_from} column variable whose values will become new
  column names.
\item
  the \emph{values\_from} column variable whose values will fill the new
  column variables.
\end{enumerate}

Further arguments include \texttt{values\_fill} which, if set, fills in
missing values with the value provided.

Let's use \texttt{pivot\_wider()} to transform interviews to create new
columns for each item owned by a household. There are a couple of new
concepts in this transformation, so let's walk through it line by line.
First we create a new object (\texttt{interviews\_items\_owned}) based
on the \texttt{interviews} data frame.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews\_items\_owned }\OtherTok{\textless{}{-}}\NormalTok{ interviews }\SpecialCharTok{\%\textgreater{}\%}
\end{Highlighting}
\end{Shaded}

Then we will actually need to make our data frame longer, because we
have multiple items in a single cell. We will use a new function,
\texttt{separate\_longer\_delim()}, from the \textbf{\texttt{tidyr}}
package to separate the values of \texttt{items\_owned} based on the
presence of semi-colons (\texttt{;}). The values of this variable were
multiple items separated by semi-colons, so this action creates a row
for each item listed in a household's possession. Thus, we end up with a
long format version of the dataset, with multiple rows for each
respondent. For example, if a respondent has a television and a solar
panel, that respondent will now have two rows, one with ``television''
and the other with ``solar panel'' in the \texttt{items\_owned} column.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{separate\_longer\_delim}\NormalTok{(items\_owned, }\AttributeTok{delim =} \StringTok{";"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
\end{Highlighting}
\end{Shaded}

After this transformation, you may notice that the \texttt{items\_owned}
column contains \texttt{NA} values. This is because some of the
respondents did not own any of the items in the interviewer's list. We
can use the \texttt{replace\_na()} function to change these \texttt{NA}
values to something more meaningful. The \texttt{replace\_na()} function
expects for you to give it a \texttt{list()} of columns that you would
like to replace the \texttt{NA} values in, and the value that you would
like to replace the \texttt{NA}s. This ends up looking like this:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{replace\_na}\NormalTok{(}\FunctionTok{list}\NormalTok{(}\AttributeTok{items\_owned =} \StringTok{"no\_listed\_items"}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
\end{Highlighting}
\end{Shaded}

Next, we create a new variable named \texttt{items\_owned\_logical},
which has one value (\texttt{TRUE}) for every row. This makes sense,
since each item in every row was owned by that household. We are
constructing this variable so that when we spread the
\texttt{items\_owned} across multiple columns, we can fill the values of
those columns with logical values describing whether the household did
(\texttt{TRUE}) or did not (\texttt{FALSE}) own that particular item.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mutate}\NormalTok{(}\AttributeTok{items\_owned\_logical =} \ConstantTok{TRUE}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{fig/separate_longer.png}}

At this point, we can also count the number of items owned by each
household, which is equivalent to the number of rows per
\texttt{key\_ID}. We can do this with a \texttt{group\_by()} and
\texttt{mutate()} pipeline that works similar to \texttt{group\_by()}
and \texttt{summarize()} discussed in the previous episode but instead
of creating a summary table, we will add another column called
\texttt{number\_items}. We use the \texttt{n()} function to count the
number of rows within each group. However, there is one difficulty we
need to take into account, namely those households that did not list any
items. These households now have \texttt{"no\_listed\_items"} under
\texttt{items\_owned}. We do not want to count this as an item but
instead show zero items. We can accomplish this using
\textbf{\texttt{dplyr}'s} \texttt{if\_else()} function that evaluates a
condition and returns one value if true and another if false. Here, if
the \texttt{items\_owned} column is \texttt{"no\_listed\_items"}, then a
0 is returned, otherwise, the number of rows per group is returned using
\texttt{n()}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{group\_by}\NormalTok{(key\_ID) }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{number\_items =} \FunctionTok{if\_else}\NormalTok{(items\_owned }\SpecialCharTok{==} \StringTok{"no\_listed\_items"}\NormalTok{, }\DecValTok{0}\NormalTok{, }\FunctionTok{n}\NormalTok{())) }\SpecialCharTok{\%\textgreater{}\%} 
\end{Highlighting}
\end{Shaded}

Lastly, we use \texttt{pivot\_wider()} to switch from long format to
wide format. This creates a new column for each of the unique values in
the \texttt{items\_owned} column, and fills those columns with the
values of \texttt{items\_owned\_logical}. We also declare that for items
that are missing, we want to fill those cells with the value of
\texttt{FALSE} instead of \texttt{NA}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{pivot\_wider}\NormalTok{(}\AttributeTok{names\_from =}\NormalTok{ items\_owned,}
            \AttributeTok{values\_from =}\NormalTok{ items\_owned\_logical,}
            \AttributeTok{values\_fill =} \FunctionTok{list}\NormalTok{(}\AttributeTok{items\_owned\_logical =} \ConstantTok{FALSE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{fig/pivot_wider.png}}

Combining the above steps, the chunk looks like this. Note that two new
columns are created within the same \texttt{mutate()} call.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews\_items\_owned }\OtherTok{\textless{}{-}}\NormalTok{ interviews }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{separate\_longer\_delim}\NormalTok{(items\_owned, }\AttributeTok{delim =} \StringTok{";"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{replace\_na}\NormalTok{(}\FunctionTok{list}\NormalTok{(}\AttributeTok{items\_owned =} \StringTok{"no\_listed\_items"}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(key\_ID) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{items\_owned\_logical =} \ConstantTok{TRUE}\NormalTok{,}
         \AttributeTok{number\_items =} \FunctionTok{if\_else}\NormalTok{(items\_owned }\SpecialCharTok{==} \StringTok{"no\_listed\_items"}\NormalTok{, }\DecValTok{0}\NormalTok{, }\FunctionTok{n}\NormalTok{())) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pivot\_wider}\NormalTok{(}\AttributeTok{names\_from =}\NormalTok{ items\_owned,}
              \AttributeTok{values\_from =}\NormalTok{ items\_owned\_logical,}
              \AttributeTok{values\_fill =} \FunctionTok{list}\NormalTok{(}\AttributeTok{items\_owned\_logical =} \ConstantTok{FALSE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

View the \texttt{interviews\_items\_owned} data frame. It should have
\texttt{r\ nrow(interviews)} rows (the same number of rows you had
originally), but extra columns for each item. How many columns were
added? Notice that there is no longer a column titled
\texttt{items\_owned}. This is because there is a default parameter in
\texttt{pivot\_wider()} that drops the original column. The values that
were in that column have now become columns named \texttt{television},
\texttt{solar\_panel}, \texttt{table}, etc. You can use
\texttt{dim(interviews)} and \texttt{dim(interviews\_wide)} to see how
the number of columns has changed between the two datasets.

This format of the data allows us to do interesting things, like make a
table showing the number of respondents in each village who owned a
particular item:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews\_items\_owned }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(bicycle) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(village) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{count}\NormalTok{(bicycle)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 3 x 3
# Groups:   village [3]
  village  bicycle     n
  <chr>    <lgl>   <int>
1 Chirodzo TRUE       17
2 God      TRUE       23
3 Ruaca    TRUE       20
\end{verbatim}

Or below we calculate the average number of items from the list owned by
respondents in each village using the \texttt{number\_items} column we
created to count the items listed by each household.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews\_items\_owned }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{group\_by}\NormalTok{(village) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{summarize}\NormalTok{(}\AttributeTok{mean\_items =} \FunctionTok{mean}\NormalTok{(number\_items))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 3 x 2
  village  mean_items
  <chr>         <dbl>
1 Chirodzo       4.54
2 God            3.98
3 Ruaca          5.57
\end{verbatim}

\section{Exercise}\label{exercise-10}

We created \texttt{interviews\_items\_owned} by reshaping the data:
first longer and then wider. Replicate this process with the
\texttt{months\_lack\_food} column in the \texttt{interviews} dataframe.
Create a new dataframe with columns for each of the months filled with
logical vectors (\texttt{TRUE} or \texttt{FALSE}) and a summary column
called \texttt{number\_months\_lack\_food} that calculates the number of
months each household reported a lack of food.

Note that if the household did not lack food in the previous 12 months,
the value input was ``none''.

\begin{solution}[Solution]
\leavevmode

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{months\_lack\_food }\OtherTok{\textless{}{-}}\NormalTok{ interviews }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{separate\_longer\_delim}\NormalTok{(months\_lack\_food, }\AttributeTok{delim =} \StringTok{";"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(key\_ID) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{months\_lack\_food\_logical =} \ConstantTok{TRUE}\NormalTok{,}
         \AttributeTok{number\_months\_lack\_food =} \FunctionTok{if\_else}\NormalTok{(months\_lack\_food }\SpecialCharTok{==} \StringTok{"none"}\NormalTok{, }\DecValTok{0}\NormalTok{, }\FunctionTok{n}\NormalTok{())) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pivot\_wider}\NormalTok{(}\AttributeTok{names\_from =}\NormalTok{ months\_lack\_food,}
              \AttributeTok{values\_from =}\NormalTok{ months\_lack\_food\_logical,}
              \AttributeTok{values\_fill =} \FunctionTok{list}\NormalTok{(}\AttributeTok{months\_lack\_food\_logical =} \ConstantTok{FALSE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\end{solution}

\section{Pivoting longer}\label{pivoting-longer}

The opposing situation could occur if we had been provided with data in
the form of \texttt{interviews\_wide}, where the items owned are column
names, but we wish to treat them as values of an \texttt{items\_owned}
variable instead.

In this situation we are gathering these columns turning them into a
pair of new variables. One variable includes the column names as values,
and the other variable contains the values in each cell previously
associated with the column names. We will do this in two steps to make
this process a bit clearer.

\texttt{pivot\_longer()} takes four principal arguments:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  the data
\item
  \emph{cols} are the names of the columns we use to fill the a new
  values variable (or to drop).
\item
  the \emph{names\_to} column variable we wish to create from the
  \emph{cols} provided.
\item
  the \emph{values\_to} column variable we wish to create and fill with
  values associated with the \emph{cols} provided.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews\_long }\OtherTok{\textless{}{-}}\NormalTok{ interviews\_items\_owned }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pivot\_longer}\NormalTok{(}\AttributeTok{cols =}\NormalTok{ bicycle}\SpecialCharTok{:}\NormalTok{car,}
               \AttributeTok{names\_to =} \StringTok{"items\_owned"}\NormalTok{,}
               \AttributeTok{values\_to =} \StringTok{"items\_owned\_logical"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

View both \texttt{interviews\_long} and
\texttt{interviews\_items\_owned} and compare their structure.

\section{Exercise}\label{exercise-11}

We created some summary tables on \texttt{interviews\_items\_owned}
using \texttt{count} and \texttt{summarise}. We can create the same
tables on \texttt{interviews\_long}, but this will require a different
process.

Make a table showing the number of respondents in each village who owned
a particular item, and include all items. The difference between this
format and the wide format is that you can now \texttt{count} all the
items using the \texttt{items\_owned} variable.

\begin{solution}[Solution]
\leavevmode

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews\_long }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(items\_owned\_logical) }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{group\_by}\NormalTok{(village) }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{count}\NormalTok{(items\_owned)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 47 x 3
# Groups:   village [3]
   village  items_owned         n
   <chr>    <chr>           <int>
 1 Chirodzo bicycle            17
 2 Chirodzo computer            2
 3 Chirodzo cow_cart            6
 4 Chirodzo cow_plough         20
 5 Chirodzo electricity         1
 6 Chirodzo fridge              1
 7 Chirodzo lorry               1
 8 Chirodzo mobile_phone       25
 9 Chirodzo motorcyle          13
10 Chirodzo no_listed_items     3
# i 37 more rows
\end{verbatim}

\end{solution}

\section{Applying what we learned to clean our
data}\label{applying-what-we-learned-to-clean-our-data}

Now we have simultaneously learned about \texttt{pivot\_longer()} and
\texttt{pivot\_wider()}, and fixed a problem in the way our data is
structured. In this dataset, we have another column that stores multiple
values in a single cell. Some of the cells in the
\texttt{months\_lack\_food} column contain multiple months which, as
before, are separated by semi-colons (\texttt{;}).

To create a data frame where each of the columns contain only one value
per cell, we can repeat the steps we applied to \texttt{items\_owned}
and apply them to \texttt{months\_lack\_food}. Since we will be using
this data frame for the next episode, we will call it
\texttt{interviews\_plotting}.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Plotting data \#\#}
\NormalTok{interviews\_plotting }\OtherTok{\textless{}{-}}\NormalTok{ interviews }\SpecialCharTok{\%\textgreater{}\%}
  \DocumentationTok{\#\# pivot wider by items\_owned}
  \FunctionTok{separate\_longer\_delim}\NormalTok{(items\_owned, }\AttributeTok{delim =} \StringTok{";"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{replace\_na}\NormalTok{(}\FunctionTok{list}\NormalTok{(}\AttributeTok{items\_owned =} \StringTok{"no\_listed\_items"}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \DocumentationTok{\#\# Use of grouped mutate to find number of rows}
  \FunctionTok{group\_by}\NormalTok{(key\_ID) }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{items\_owned\_logical =} \ConstantTok{TRUE}\NormalTok{,}
         \AttributeTok{number\_items =} \FunctionTok{if\_else}\NormalTok{(items\_owned }\SpecialCharTok{==} \StringTok{"no\_listed\_items"}\NormalTok{, }\DecValTok{0}\NormalTok{, }\FunctionTok{n}\NormalTok{())) }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{pivot\_wider}\NormalTok{(}\AttributeTok{names\_from =}\NormalTok{ items\_owned,}
              \AttributeTok{values\_from =}\NormalTok{ items\_owned\_logical,}
              \AttributeTok{values\_fill =} \FunctionTok{list}\NormalTok{(}\AttributeTok{items\_owned\_logical =} \ConstantTok{FALSE}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%} 
  \DocumentationTok{\#\# pivot wider by months\_lack\_food}
  \FunctionTok{separate\_longer\_delim}\NormalTok{(months\_lack\_food, }\AttributeTok{delim =} \StringTok{";"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{months\_lack\_food\_logical =} \ConstantTok{TRUE}\NormalTok{,}
         \AttributeTok{number\_months\_lack\_food =} \FunctionTok{if\_else}\NormalTok{(months\_lack\_food }\SpecialCharTok{==} \StringTok{"none"}\NormalTok{, }\DecValTok{0}\NormalTok{, }\FunctionTok{n}\NormalTok{())) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pivot\_wider}\NormalTok{(}\AttributeTok{names\_from =}\NormalTok{ months\_lack\_food,}
              \AttributeTok{values\_from =}\NormalTok{ months\_lack\_food\_logical,}
              \AttributeTok{values\_fill =} \FunctionTok{list}\NormalTok{(}\AttributeTok{months\_lack\_food\_logical =} \ConstantTok{FALSE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\section{Exporting data}\label{exporting-data}

Now that you have learned how to use \textbf{\texttt{dplyr}} and
\textbf{\texttt{tidyr}} to wrangle your raw data, you may want to export
these new datasets to share them with your collaborators or for archival
purposes.

Similar to the \texttt{read\_csv()} function used for reading CSV files
into R, there is a \texttt{write\_csv()} function that generates CSV
files from data frames.

Before using \texttt{write\_csv()}, we are going to create a new folder,
\texttt{data\_output}, in our working directory that will store this
generated dataset. We don't want to write generated datasets in the same
directory as our raw data. It's good practice to keep them separate. The
\texttt{data} folder should only contain the raw, unaltered data, and
should be left alone to make sure we don't delete or modify it. In
contrast, our script will generate the contents of the
\texttt{data\_output} directory, so even if the files it contains are
deleted, we can always re-generate them.

In preparation for our next lesson on plotting, we created a version of
the dataset where each of the columns includes only one data value. Now
we can save this data frame to our \texttt{data\_output} directory.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{write\_csv}\NormalTok{(interviews\_plotting, }\AttributeTok{file =} \StringTok{"data\_output/interviews\_plotting.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Use the \texttt{tidyr} package to change the layout of data frames.
\item
  Use \texttt{pivot\_wider()} to go from long to wide format.
\item
  Use \texttt{pivot\_longer()} to go from wide to long format.
\end{itemize}

\bookmarksetup{startatroot}

\chapter{Data Visualisation with
ggplot2}\label{data-visualisation-with-ggplot2}

\begin{itemize}
\tightlist
\item
  This episode is a broad overview of ggplot2 and focuses on (1) getting
  familiar with the layering system of ggplot2, (2) using the argument
  \texttt{group} in the \texttt{aes()} function, (3) basic customization
  of the plots.
\item
  The episode depends on data created in the Data Wrangling with tidyr
  episode. If you did not get to or through all of the tidyr episode,
  you can have the learners access the data by either downloading it or
  quickly creating it using the tidyr code below. You will probably want
  to copy the code into the Etherpad.
\item
  If you did skip the tidyr episode, you might want to go over the
  exporting data section in that episode.
\end{itemize}

\begin{itemize}
\tightlist
\item
  Produce scatter plots, boxplots, and barplots using ggplot.
\item
  Set universal plot settings.
\item
  Describe what faceting is and apply faceting in ggplot.
\item
  Modify the aesthetics of an existing ggplot plot (including axis
  labels and colour).
\item
  Build complex and customized plots from data in a data frame.
\item
  Recognize the differences between base R, lattice, and ggplot
  visualizations.
\end{itemize}

\begin{itemize}
\tightlist
\item
  What are the components of a ggplot?
\item
  What are the main differences between R base plots, lattice, and
  ggplot?
\item
  How do I create scatterplots, boxplots, and barplots?
\item
  How can I change the aesthetics (ex. colour, transparency) of my plot?
\item
  How can I create multiple plots at once?
\end{itemize}

We start by loading the required package. \textbf{\texttt{ggplot2}} is
also included in the \textbf{\texttt{tidyverse}} package.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(tidyverse)}
\end{Highlighting}
\end{Shaded}

If not still in the workspace, load the data we saved in the previous
lesson.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews\_plotting }\OtherTok{\textless{}{-}} \FunctionTok{read\_csv}\NormalTok{(}\StringTok{"data\_output/interviews\_plotting.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Rows: 131 Columns: 45
-- Column specification --------------------------------------------------------
Delimiter: ","
chr   (5): village, respondent_wall_type, memb_assoc, affect_conflicts, inst...
dbl   (8): key_ID, no_membrs, years_liv, rooms, liv_count, no_meals, number_...
lgl  (31): bicycle, television, solar_panel, table, cow_cart, radio, cow_plo...
dttm  (1): interview_date

i Use `spec()` to retrieve the full column specification for this data.
i Specify the column types or set `show_col_types = FALSE` to quiet this message.
\end{verbatim}

If you were unable to complete the previous lesson or did not save the
data, then you can create it now. Either download it using
\texttt{read\_csv()} (Option 1) or create it with the \textbf{dplyr} and
\textbf{tidyr} code (Option 2).

\subsection{Option 1: Download the
data}\label{option-1-download-the-data}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews\_plotting }\OtherTok{\textless{}{-}} \FunctionTok{read\_csv}\NormalTok{(}\StringTok{"https://raw.githubusercontent.com/datacarpentry/r{-}socialsci/main/episodes/data/interviews\_plotting.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\subsection{Option 2: Create the data}\label{option-2-create-the-data}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Can be used to load in data from previous lesson!}
\NormalTok{interviews\_plotting }\OtherTok{\textless{}{-}}\NormalTok{ interviews }\SpecialCharTok{\%\textgreater{}\%}
  \DocumentationTok{\#\# pivot wider by items\_owned}
  \FunctionTok{separate\_longer\_delim}\NormalTok{(items\_owned, }\AttributeTok{delim =} \StringTok{";"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{replace\_na}\NormalTok{(}\FunctionTok{list}\NormalTok{(}\AttributeTok{items\_owned =} \StringTok{"no\_listed\_items"}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \DocumentationTok{\#\# Use of grouped mutate to find number of rows}
  \FunctionTok{group\_by}\NormalTok{(key\_ID) }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{items\_owned\_logical =} \ConstantTok{TRUE}\NormalTok{,}
         \AttributeTok{number\_items =} \FunctionTok{if\_else}\NormalTok{(items\_owned }\SpecialCharTok{==} \StringTok{"no\_listed\_items"}\NormalTok{, }\DecValTok{0}\NormalTok{, }\FunctionTok{n}\NormalTok{())) }\SpecialCharTok{\%\textgreater{}\%} 
  \FunctionTok{pivot\_wider}\NormalTok{(}\AttributeTok{names\_from =}\NormalTok{ items\_owned,}
              \AttributeTok{values\_from =}\NormalTok{ items\_owned\_logical,}
              \AttributeTok{values\_fill =} \FunctionTok{list}\NormalTok{(}\AttributeTok{items\_owned\_logical =} \ConstantTok{FALSE}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%} 
  \DocumentationTok{\#\# pivot wider by months\_lack\_food}
  \FunctionTok{separate\_longer\_delim}\NormalTok{(months\_lack\_food, }\AttributeTok{delim =} \StringTok{";"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{months\_lack\_food\_logical =} \ConstantTok{TRUE}\NormalTok{,}
         \AttributeTok{number\_months\_lack\_food =} \FunctionTok{if\_else}\NormalTok{(months\_lack\_food }\SpecialCharTok{==} \StringTok{"none"}\NormalTok{, }\DecValTok{0}\NormalTok{, }\FunctionTok{n}\NormalTok{())) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{pivot\_wider}\NormalTok{(}\AttributeTok{names\_from =}\NormalTok{ months\_lack\_food,}
              \AttributeTok{values\_from =}\NormalTok{ months\_lack\_food\_logical,}
              \AttributeTok{values\_fill =} \FunctionTok{list}\NormalTok{(}\AttributeTok{months\_lack\_food\_logical =} \ConstantTok{FALSE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\section{Visualization Options in R}\label{visualization-options-in-r}

Before we start with \textbf{\texttt{ggplot2}}, it's helpful to know
that there are several ways to create visualizations in R. While
\textbf{\texttt{ggplot2}} is great for building complex and highly
customizable plots, there are simpler and quicker alternatives that you
might encounter or use depending on the context. Let's briefly explore a
few of them:

\subsection{R Base Plots}\label{r-base-plots}

Base R plots are the simplest form of visualization and are great for
quick, exploratory analysis. You can create plots with very little code,
but customizing them can be cumbersome compared to
\textbf{\texttt{ggplot2}}.

Example of a simple scatterplot in base R using the \texttt{no\_membrs}
and \texttt{liv\_count} variables:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{plot}\NormalTok{(interviews\_plotting}\SpecialCharTok{$}\NormalTok{no\_membrs, interviews\_plotting}\SpecialCharTok{$}\NormalTok{liv\_count,}
     \AttributeTok{main =} \StringTok{"Base R Scatterplot"}\NormalTok{,}
     \AttributeTok{xlab =} \StringTok{"Number of Household Members"}\NormalTok{,}
     \AttributeTok{ylab =} \StringTok{"Number of Livestock Owned"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{05-ggplot2_files/figure-pdf/unnamed-chunk-3-1.pdf}}

\subsection{\texorpdfstring{\textbf{\texttt{Lattice}}}{Lattice}}\label{lattice}

Lattice is another plotting system in R, which allows for creating
multi-panel plots easily. It's different from ggplot2 because you define
the entire plot in a single function call, and modifications after
plotting are limited.

Example of a lattice plot using \texttt{no\_membrs} and
\texttt{liv\_count} split by \texttt{village}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(lattice)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{xyplot}\NormalTok{(liv\_count }\SpecialCharTok{\textasciitilde{}}\NormalTok{ no\_membrs }\SpecialCharTok{|}\NormalTok{ village, }\AttributeTok{data =}\NormalTok{ interviews\_plotting,}
       \AttributeTok{main =} \StringTok{"Lattice Plot: Livestock Count by Household Members"}\NormalTok{,}
       \AttributeTok{xlab =} \StringTok{"Number of Household Members"}\NormalTok{,}
       \AttributeTok{ylab =} \StringTok{"Number of Livestock Owned"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{05-ggplot2_files/figure-pdf/unnamed-chunk-4-1.pdf}}

\section{\texorpdfstring{Plotting with
\textbf{\texttt{ggplot2}}}{Plotting with ggplot2}}\label{plotting-with-ggplot2}

\textbf{\texttt{ggplot2}} is a plotting package that makes it simple to
create complex plots from data stored in a data frame. It provides a
programmatic interface for specifying what variables to plot, how they
are displayed, and general visual properties. Therefore, we only need
minimal changes if the underlying data change or if we decide to change
from a bar plot to a scatterplot. This helps in creating publication
quality plots with minimal amounts of adjustments and tweaking.

\textbf{\texttt{ggplot2}} functions work best with data in the `long'
format, i.e., a column for every dimension, and a row for every
observation. Well-structured data will save you lots of time when making
figures with \textbf{\texttt{ggplot2}}

ggplot graphics are built step by step by adding new elements. Adding
layers in this fashion allows for extensive flexibility and
customization of plots.

Each chart built with ggplot2 must include the following

\begin{itemize}
\item
  Data
\item
  Aesthetic mapping (aes)

  \begin{itemize}
  \tightlist
  \item
    Describes how variables are mapped onto graphical attributes
  \item
    Visual attribute of data including x-y axes, color, fill, shape, and
    alpha
  \end{itemize}
\item
  Geometric objects (geom)

  \begin{itemize}
  \tightlist
  \item
    Determines how values are rendered graphically, as bars
    (\texttt{geom\_bar}), scatterplot (\texttt{geom\_point}), line
    (\texttt{geom\_line}), etc.
  \end{itemize}
\end{itemize}

Thus, the template for graphic in ggplot2 is:

\begin{verbatim}
<DATA> %>%
    ggplot(aes(<MAPPINGS>)) +
    <GEOM_FUNCTION>()
\end{verbatim}

Remember from the last lesson that the pipe operator
\texttt{\%\textgreater{}\%} places the result of the previous line(s)
into the first argument of the function. \textbf{\texttt{ggplot}} is a
function that expects a data frame to be the first argument. This allows
for us to change from specifying the \texttt{data\ =} argument within
the \texttt{ggplot} function and instead pipe the data into the
function.

\begin{itemize}
\tightlist
\item
  use the \texttt{ggplot()} function and bind the plot to a specific
  data frame.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews\_plotting }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{ggplot}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  define a mapping (using the aesthetic (\texttt{aes}) function), by
  selecting the variables to be plotted and specifying how to present
  them in the graph, e.g.~as x/y positions or characteristics such as
  size, shape, color, etc.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews\_plotting }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ no\_membrs, }\AttributeTok{y =}\NormalTok{ number\_items))}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\item
  add `geoms' -- graphical representations of the data in the plot
  (points, lines, bars). \textbf{\texttt{ggplot2}} offers many different
  geoms; we will use some common ones today, including:

  \begin{itemize}
  \tightlist
  \item
    \texttt{geom\_point()} for scatter plots, dot plots, etc.
  \item
    \texttt{geom\_boxplot()} for, well, boxplots!
  \item
    \texttt{geom\_line()} for trend lines, time series, etc.
  \end{itemize}
\end{itemize}

To add a geom to the plot use the \texttt{+} operator. Because we have
two continuous variables, let's use \texttt{geom\_point()} first:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews\_plotting }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ no\_membrs, }\AttributeTok{y =}\NormalTok{ number\_items)) }\SpecialCharTok{+}
    \FunctionTok{geom\_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{05-ggplot2_files/figure-pdf/first-ggplot-1.pdf}}

The \texttt{+} in the \textbf{\texttt{ggplot2}} package is particularly
useful because it allows you to modify existing \texttt{ggplot} objects.
This means you can easily set up plot templates and conveniently explore
different types of plots, so the above plot can also be generated with
code like this, similar to the ``intermediate steps'' approach in the
previous lesson:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Assign plot to a variable}
\NormalTok{interviews\_plot }\OtherTok{\textless{}{-}}\NormalTok{ interviews\_plotting }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ no\_membrs, }\AttributeTok{y =}\NormalTok{ number\_items))}

\CommentTok{\# Draw the plot as a dot plot}
\NormalTok{interviews\_plot }\SpecialCharTok{+}
    \FunctionTok{geom\_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, opacityback=0, left=2mm, bottomrule=.15mm, toprule=.15mm, breakable, colback=white, arc=.35mm, colframe=quarto-callout-color-frame, rightrule=.15mm, leftrule=.75mm]

\vspace{-3mm}\textbf{Notes}\vspace{3mm}

\begin{itemize}
\tightlist
\item
  Anything you put in the \texttt{ggplot()} function can be seen by any
  geom layers that you add (i.e., these are universal plot settings).
  This includes the x- and y-axis mapping you set up in \texttt{aes()}.
\item
  You can also specify mappings for a given geom independently of the
  mapping defined globally in the \texttt{ggplot()} function.
\item
  The \texttt{+} sign used to add new layers must be placed at the end
  of the line containing the \emph{previous} layer. If, instead, the
  \texttt{+} sign is added at the beginning of the line containing the
  new layer, \textbf{\texttt{ggplot2}} will not add the new layer and
  will return an error message.
\end{itemize}

\end{tcolorbox}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# This is the correct syntax for adding layers}
\NormalTok{interviews\_plot }\SpecialCharTok{+}
    \FunctionTok{geom\_point}\NormalTok{()}

\DocumentationTok{\#\# This will not add the new layer and will return an error message}
\NormalTok{interviews\_plot}
\SpecialCharTok{+} \FunctionTok{geom\_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\section{Building your plots
iteratively}\label{building-your-plots-iteratively}

Building plots with \textbf{\texttt{ggplot2}} is typically an iterative
process. We start by defining the dataset we'll use, lay out the axes,
and choose a geom:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews\_plotting }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ no\_membrs, }\AttributeTok{y =}\NormalTok{ number\_items)) }\SpecialCharTok{+}
    \FunctionTok{geom\_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{05-ggplot2_files/figure-pdf/create-ggplot-object-1.pdf}}

Then, we start modifying this plot to extract more information from it.
For instance, when inspecting the plot we notice that points only appear
at the intersection of whole numbers of \texttt{no\_membrs} and
\texttt{number\_items}. Also, from a rough estimate, it looks like there
are far fewer dots on the plot than there rows in our dataframe. This
should lead us to believe that there may be multiple observations
plotted on top of each other (e.g.~three observations where
\texttt{no\_membrs} is 3 and \texttt{number\_items} is 1).

There are two main ways to alleviate overplotting issues:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  changing the transparency of the points
\item
  jittering the location of the points
\end{enumerate}

Let's first explore option 1, changing the transparency of the points.
What we mean when we say ``transparency'' we mean the opacity of point,
or your ability to see through the point. We can control the
transparency of the points with the \texttt{alpha} argument to
\texttt{geom\_point}. Values of \texttt{alpha} range from 0 to 1, with
lower values corresponding to more transparent colors (an \texttt{alpha}
of 1 is the default value). Specifically, an alpha of 0.1, would make a
point one-tenth as opaque as a normal point. Stated differently ten
points stacked on top of each other would correspond to a normal point.

Here, we change the \texttt{alpha} to 0.5, in an attempt to help fix the
overplotting. While the overplotting isn't solved, adding transparency
begins to address this problem, as the points where there are
overlapping observations are darker (as opposed to lighter gray):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews\_plotting }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ no\_membrs, }\AttributeTok{y =}\NormalTok{ number\_items)) }\SpecialCharTok{+}
    \FunctionTok{geom\_point}\NormalTok{(}\AttributeTok{alpha =} \FloatTok{0.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{05-ggplot2_files/figure-pdf/adding-transparency-1.pdf}}

That only helped a little bit with the overplotting problem, so let's
try option two. We can jitter the points on the plot, so that we can see
each point in the locations where there are overlapping points.
Jittering introduces a little bit of randomness into the position of our
points. You can think of this process as taking the overplotted graph
and giving it a tiny shake. The points will move a little bit
side-to-side and up-and-down, but their position from the original plot
won't dramatically change. Note that this solution is suitable for
plotting integer figures, while for numeric figures with decimals,
geom\_jitter() becomes inappropriate because it obscures the true value
of the observation.

We can jitter our points using the \texttt{geom\_jitter()} function
instead of the \texttt{geom\_point()} function, as seen below:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews\_plotting }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ no\_membrs, }\AttributeTok{y =}\NormalTok{ number\_items)) }\SpecialCharTok{+}
    \FunctionTok{geom\_jitter}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{05-ggplot2_files/figure-pdf/adding-jitter-1.pdf}}

The \texttt{geom\_jitter()} function allows for us to specify the amount
of random motion in the jitter, using the \texttt{width} and
\texttt{height} arguments. When we don't specify values for
\texttt{width} and \texttt{height}, \texttt{geom\_jitter()} defaults to
40\% of the resolution of the data (the smallest change that can be
measured). Hence, if we would like \emph{less} spread in our jitter than
was default, we should pick values between 0.1 and 0.4. Experiment with
the values to see how your plot changes.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews\_plotting }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ no\_membrs, }\AttributeTok{y =}\NormalTok{ number\_items)) }\SpecialCharTok{+}
    \FunctionTok{geom\_jitter}\NormalTok{(}\AttributeTok{alpha =} \FloatTok{0.5}\NormalTok{,}
                \AttributeTok{width =} \FloatTok{0.2}\NormalTok{,}
                \AttributeTok{height =} \FloatTok{0.2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{05-ggplot2_files/figure-pdf/adding-width-height-1.pdf}}

For our final change, we can also add colours for all the points by
specifying a \texttt{color} argument inside the \texttt{geom\_jitter()}
function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews\_plotting }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ no\_membrs, }\AttributeTok{y =}\NormalTok{ number\_items)) }\SpecialCharTok{+}
    \FunctionTok{geom\_jitter}\NormalTok{(}\AttributeTok{alpha =} \FloatTok{0.5}\NormalTok{,}
                \AttributeTok{color =} \StringTok{"blue"}\NormalTok{,}
                \AttributeTok{width =} \FloatTok{0.2}\NormalTok{,}
                \AttributeTok{height =} \FloatTok{0.2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{05-ggplot2_files/figure-pdf/adding-colors-1.pdf}}

To colour each village in the plot differently, you could use a vector
as an input to the argument \textbf{\texttt{color}}. However, because we
are now mapping features of the data to a colour, instead of setting one
colour for all points, the colour of the points now needs to be set
inside a call to the \textbf{\texttt{aes}} function. When we map a
variable in our data to the colour of the points,
\textbf{\texttt{ggplot2}} will provide a different colour corresponding
to the different values of the variable. We will continue to specify the
value of \textbf{\texttt{alpha}}, \textbf{\texttt{width}}, and
\textbf{\texttt{height}} outside of the \textbf{\texttt{aes}} function
because we are using the same value for every point. ggplot2 understands
both the Commonwealth English and American English spellings for colour,
i.e., you can use either \texttt{color} or \texttt{colour}. Here is an
example where we color points by the \textbf{\texttt{village}} of the
observation:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews\_plotting }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ no\_membrs, }\AttributeTok{y =}\NormalTok{ number\_items)) }\SpecialCharTok{+}
    \FunctionTok{geom\_jitter}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{color =}\NormalTok{ village), }\AttributeTok{alpha =} \FloatTok{0.5}\NormalTok{, }\AttributeTok{width =} \FloatTok{0.2}\NormalTok{, }\AttributeTok{height =} \FloatTok{0.2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{05-ggplot2_files/figure-pdf/color-by-species-1.pdf}}

There appears to be a positive trend between number of household members
and number of items owned (from the list provided). Additionally, this
trend does not appear to be different by village.

\begin{tcolorbox}[enhanced jigsaw, opacityback=0, left=2mm, bottomrule=.15mm, toprule=.15mm, breakable, colback=white, arc=.35mm, colframe=quarto-callout-color-frame, rightrule=.15mm, leftrule=.75mm]

\vspace{-3mm}\textbf{Notes}\vspace{3mm}

As you will learn, there are multiple ways to plot the a relationship
between variables. Another way to plot data with overlapping points is
to use the \texttt{geom\_count} plotting function. The
\texttt{geom\_count()} function makes the size of each point
representative of the number of data items of that type and the legend
gives point sizes associated to particular numbers of items.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews\_plotting }\SpecialCharTok{\%\textgreater{}\%}
   \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ no\_membrs, }\AttributeTok{y =}\NormalTok{ number\_items, }\AttributeTok{color =}\NormalTok{ village)) }\SpecialCharTok{+}
   \FunctionTok{geom\_count}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{05-ggplot2_files/figure-pdf/color-by-species-notes-1.pdf}}

\end{tcolorbox}

\section{Exercise}\label{exercise-12}

Use what you just learned to create a scatter plot of \texttt{rooms} by
\texttt{village} with the \texttt{respondent\_wall\_type} showing in
different colours. Does this seem like a good way to display the
relationship between these variables? What other kinds of plots might
you use to show this type of data?

\begin{solution}[Solution]
\leavevmode

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews\_plotting }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ village, }\AttributeTok{y =}\NormalTok{ rooms)) }\SpecialCharTok{+}
    \FunctionTok{geom\_jitter}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{color =}\NormalTok{ respondent\_wall\_type),}
        \AttributeTok{alpha =} \FloatTok{0.5}\NormalTok{,}
            \AttributeTok{width =} \FloatTok{0.2}\NormalTok{,}
            \AttributeTok{height =} \FloatTok{0.2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{05-ggplot2_files/figure-pdf/scatter-challenge-1.pdf}}

This is not a great way to show this type of data because it is
difficult to distinguish between villages. What other plot types could
help you visualize this relationship better?
\end{solution}

\section{Boxplot}\label{boxplot}

We can use boxplots to visualize the distribution of rooms for each wall
type:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews\_plotting }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ respondent\_wall\_type, }\AttributeTok{y =}\NormalTok{ rooms)) }\SpecialCharTok{+}
    \FunctionTok{geom\_boxplot}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{05-ggplot2_files/figure-pdf/boxplot-1.pdf}}

By adding points to a boxplot, we can have a better idea of the number
of measurements and of their distribution:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews\_plotting }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ respondent\_wall\_type, }\AttributeTok{y =}\NormalTok{ rooms)) }\SpecialCharTok{+}
    \FunctionTok{geom\_boxplot}\NormalTok{(}\AttributeTok{alpha =} \DecValTok{0}\NormalTok{) }\SpecialCharTok{+}
    \FunctionTok{geom\_jitter}\NormalTok{(}\AttributeTok{alpha =} \FloatTok{0.5}\NormalTok{,}
            \AttributeTok{color =} \StringTok{"tomato"}\NormalTok{,}
            \AttributeTok{width =} \FloatTok{0.2}\NormalTok{,}
            \AttributeTok{height =} \FloatTok{0.2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{05-ggplot2_files/figure-pdf/boxplot-with-jitter-1.pdf}}

We can see that muddaub houses and sunbrick houses tend to be smaller
than burntbrick houses.

Notice how the boxplot layer is behind the jitter layer? What do you
need to change in the code to put the boxplot layer in front of the
jitter layer?

\section{Exercise}\label{exercise-13}

Boxplots are useful summaries, but hide the \emph{shape} of the
distribution. For example, if the distribution is bimodal, we would not
see it in a boxplot. An alternative to the boxplot is the violin plot,
where the shape (of the density of points) is drawn.

\begin{itemize}
\tightlist
\item
  Replace the box plot with a violin plot; see \texttt{geom\_violin()}.
\end{itemize}

\begin{solution}[Solution]
\leavevmode

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews\_plotting }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ respondent\_wall\_type, }\AttributeTok{y =}\NormalTok{ rooms)) }\SpecialCharTok{+}
  \FunctionTok{geom\_violin}\NormalTok{(}\AttributeTok{alpha =} \DecValTok{0}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_jitter}\NormalTok{(}\AttributeTok{alpha =} \FloatTok{0.5}\NormalTok{, }\AttributeTok{color =} \StringTok{"tomato"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Warning: Groups with fewer than two datapoints have been dropped.
i Set `drop = FALSE` to consider such groups for position adjustment purposes.
\end{verbatim}

\pandocbounded{\includegraphics[keepaspectratio]{05-ggplot2_files/figure-pdf/violin-plot-1.pdf}}

\end{solution}

So far, we've looked at the distribution of room number within wall
type. Try making a new plot to explore the distribution of another
variable within wall type.

\begin{itemize}
\tightlist
\item
  Create a boxplot for \texttt{liv\_count} for each wall type. Overlay
  the boxplot layer on a jitter layer to show actual measurements.
\end{itemize}

\begin{solution}[Solution]
\leavevmode

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews\_plotting }\SpecialCharTok{\%\textgreater{}\%}
   \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ respondent\_wall\_type, }\AttributeTok{y =}\NormalTok{ liv\_count)) }\SpecialCharTok{+}
   \FunctionTok{geom\_boxplot}\NormalTok{(}\AttributeTok{alpha =} \DecValTok{0}\NormalTok{) }\SpecialCharTok{+}
   \FunctionTok{geom\_jitter}\NormalTok{(}\AttributeTok{alpha =} \FloatTok{0.5}\NormalTok{, }\AttributeTok{width =} \FloatTok{0.2}\NormalTok{, }\AttributeTok{height =} \FloatTok{0.2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{05-ggplot2_files/figure-pdf/boxplot-exercise-1.pdf}}

\end{solution}

\begin{itemize}
\tightlist
\item
  Add colour to the data points on your boxplot according to whether the
  respondent is a member of an irrigation association
  (\texttt{memb\_assoc}).
\end{itemize}

\begin{solution}[Solution]
\leavevmode

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews\_plotting }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ respondent\_wall\_type, }\AttributeTok{y =}\NormalTok{ liv\_count)) }\SpecialCharTok{+}
  \FunctionTok{geom\_boxplot}\NormalTok{(}\AttributeTok{alpha =} \DecValTok{0}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{geom\_jitter}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{color =}\NormalTok{ memb\_assoc), }\AttributeTok{alpha =} \FloatTok{0.5}\NormalTok{, }\AttributeTok{width =} \FloatTok{0.2}\NormalTok{, }\AttributeTok{height =} \FloatTok{0.2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{05-ggplot2_files/figure-pdf/boxplot-exercise-factor-1.pdf}}

\end{solution}

\section{Barplots}\label{barplots}

Barplots are also useful for visualizing categorical data. By default,
\texttt{geom\_bar} accepts a variable for x, and plots the number of
instances each value of x (in this case, wall type) appears in the
dataset.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews\_plotting }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ respondent\_wall\_type)) }\SpecialCharTok{+}
    \FunctionTok{geom\_bar}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{05-ggplot2_files/figure-pdf/barplot-1-1.pdf}}

We can use the \texttt{fill} aesthetic for the \texttt{geom\_bar()} geom
to colour bars by the portion of each count that is from each village.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews\_plotting }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ respondent\_wall\_type)) }\SpecialCharTok{+}
    \FunctionTok{geom\_bar}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{fill =}\NormalTok{ village))}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{05-ggplot2_files/figure-pdf/barplot-stack-1.pdf}}

This creates a stacked bar chart. These are generally more difficult to
read than side-by-side bars. We can separate the portions of the stacked
bar that correspond to each village and put them side-by-side by using
the \texttt{position} argument for \texttt{geom\_bar()} and setting it
to ``dodge''.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interviews\_plotting }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ respondent\_wall\_type)) }\SpecialCharTok{+}
    \FunctionTok{geom\_bar}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{fill =}\NormalTok{ village), }\AttributeTok{position =} \StringTok{"dodge"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{05-ggplot2_files/figure-pdf/barplot-dodge-1.pdf}}

This is a nicer graphic, but we're more likely to be interested in the
proportion of each housing type in each village than in the actual count
of number of houses of each type (because we might have sampled
different numbers of households in each village). To compare
proportions, we will first create a new data frame
(\texttt{percent\_wall\_type}) with a new column named ``percent''
representing the percent of each house type in each village. We will
remove houses with cement walls, as there was only one in the dataset.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{percent\_wall\_type }\OtherTok{\textless{}{-}}\NormalTok{ interviews\_plotting }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{filter}\NormalTok{(respondent\_wall\_type }\SpecialCharTok{!=} \StringTok{"cement"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{count}\NormalTok{(village, respondent\_wall\_type) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{group\_by}\NormalTok{(village) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{mutate}\NormalTok{(}\AttributeTok{percent =}\NormalTok{ (n }\SpecialCharTok{/} \FunctionTok{sum}\NormalTok{(n)) }\SpecialCharTok{*} \DecValTok{100}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{ungroup}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Now we can use this new data frame to create our plot showing the
percentage of each house type in each village.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{percent\_wall\_type }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ village, }\AttributeTok{y =}\NormalTok{ percent, }\AttributeTok{fill =}\NormalTok{ respondent\_wall\_type)) }\SpecialCharTok{+}
    \FunctionTok{geom\_bar}\NormalTok{(}\AttributeTok{stat =} \StringTok{"identity"}\NormalTok{, }\AttributeTok{position =} \StringTok{"dodge"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{05-ggplot2_files/figure-pdf/barplot-wall-type-1.pdf}}

\section{Exercise}\label{exercise-14}

Create a bar plot showing the proportion of respondents in each village
who are or are not part of an irrigation association
(\texttt{memb\_assoc}). Include only respondents who answered that
question in the calculations and plot. Which village had the lowest
proportion of respondents in an irrigation association?

\begin{solution}[Solution]
\leavevmode

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{percent\_memb\_assoc }\OtherTok{\textless{}{-}}\NormalTok{ interviews\_plotting }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{filter}\NormalTok{(}\SpecialCharTok{!}\FunctionTok{is.na}\NormalTok{(memb\_assoc)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{count}\NormalTok{(village, memb\_assoc) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(village) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{percent =}\NormalTok{ (n }\SpecialCharTok{/} \FunctionTok{sum}\NormalTok{(n)) }\SpecialCharTok{*} \DecValTok{100}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ungroup}\NormalTok{()}

\NormalTok{percent\_memb\_assoc }\SpecialCharTok{\%\textgreater{}\%}
   \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ village, }\AttributeTok{y =}\NormalTok{ percent, }\AttributeTok{fill =}\NormalTok{ memb\_assoc)) }\SpecialCharTok{+}
    \FunctionTok{geom\_bar}\NormalTok{(}\AttributeTok{stat =} \StringTok{"identity"}\NormalTok{, }\AttributeTok{position =} \StringTok{"dodge"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{05-ggplot2_files/figure-pdf/barplot-memb-assoc-1.pdf}}

Ruaca had the lowest proportion of members in an irrigation association.
\end{solution}

\section{Adding Labels and Titles}\label{adding-labels-and-titles}

By default, the axes labels on a plot are determined by the name of the
variable being plotted. However, \textbf{\texttt{ggplot2}} offers lots
of customization options, like specifying the axes labels, and adding a
title to the plot with relatively few lines of code. We will add more
informative x-and y-axis labels to our plot, a more explanatory label to
the legend, and a plot title.

The \texttt{labs} function takes the following arguments:

\begin{itemize}
\tightlist
\item
  \texttt{title} -- to produce a plot title
\item
  \texttt{subtitle} -- to produce a plot subtitle (smaller text placed
  beneath the title)
\item
  \texttt{caption} -- a caption for the plot
\item
  \texttt{...} -- any pair of name and value for aesthetics used in the
  plot (e.g., \texttt{x}, \texttt{y}, \texttt{fill}, \texttt{color},
  \texttt{size})
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{percent\_wall\_type }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ village, }\AttributeTok{y =}\NormalTok{ percent, }\AttributeTok{fill =}\NormalTok{ respondent\_wall\_type)) }\SpecialCharTok{+}
    \FunctionTok{geom\_bar}\NormalTok{(}\AttributeTok{stat =} \StringTok{"identity"}\NormalTok{, }\AttributeTok{position =} \StringTok{"dodge"}\NormalTok{) }\SpecialCharTok{+}
    \FunctionTok{labs}\NormalTok{(}\AttributeTok{title =} \StringTok{"Proportion of wall type by village"}\NormalTok{,}
         \AttributeTok{fill =} \StringTok{"Type of Wall in Home"}\NormalTok{,}
         \AttributeTok{x =} \StringTok{"Village"}\NormalTok{,}
         \AttributeTok{y =} \StringTok{"Percent"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{05-ggplot2_files/figure-pdf/barplot-wall-types-labeled-1.pdf}}

\section{Faceting}\label{faceting}

Rather than creating a single plot with side-by-side bars for each
village, we may want to create multiple plot, where each plot shows the
data for a single village. This would be especially useful if we had a
large number of villages that we had sampled, as a large number of
side-by-side bars will become more difficult to read.

\textbf{\texttt{ggplot2}} has a special technique called \emph{faceting}
that allows the user to split one plot into multiple plots based on a
factor included in the dataset. We will use it to split our barplot of
housing type proportion by village so that each village has its own
panel in a multi-panel plot:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{percent\_wall\_type }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ respondent\_wall\_type, }\AttributeTok{y =}\NormalTok{ percent)) }\SpecialCharTok{+}
    \FunctionTok{geom\_bar}\NormalTok{(}\AttributeTok{stat =} \StringTok{"identity"}\NormalTok{, }\AttributeTok{position =} \StringTok{"dodge"}\NormalTok{) }\SpecialCharTok{+}
    \FunctionTok{labs}\NormalTok{(}\AttributeTok{title=}\StringTok{"Proportion of wall type by village"}\NormalTok{,}
         \AttributeTok{x=}\StringTok{"Wall Type"}\NormalTok{,}
         \AttributeTok{y=}\StringTok{"Percent"}\NormalTok{) }\SpecialCharTok{+}
    \FunctionTok{facet\_wrap}\NormalTok{(}\SpecialCharTok{\textasciitilde{}}\NormalTok{ village)}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{05-ggplot2_files/figure-pdf/barplot-faceting-1.pdf}}

Click the ``Zoom'' button in your RStudio plots pane to view a larger
version of this plot.

Usually plots with white background look more readable when printed. We
can set the background to white using the function \texttt{theme\_bw()}.
Additionally, you can remove the grid:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{percent\_wall\_type }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ respondent\_wall\_type, }\AttributeTok{y =}\NormalTok{ percent)) }\SpecialCharTok{+}
    \FunctionTok{geom\_bar}\NormalTok{(}\AttributeTok{stat =} \StringTok{"identity"}\NormalTok{, }\AttributeTok{position =} \StringTok{"dodge"}\NormalTok{) }\SpecialCharTok{+}
    \FunctionTok{labs}\NormalTok{(}\AttributeTok{title=}\StringTok{"Proportion of wall type by village"}\NormalTok{,}
         \AttributeTok{x=}\StringTok{"Wall Type"}\NormalTok{,}
         \AttributeTok{y=}\StringTok{"Percent"}\NormalTok{) }\SpecialCharTok{+}
    \FunctionTok{facet\_wrap}\NormalTok{(}\SpecialCharTok{\textasciitilde{}}\NormalTok{ village) }\SpecialCharTok{+}
    \FunctionTok{theme\_bw}\NormalTok{() }\SpecialCharTok{+}
    \FunctionTok{theme}\NormalTok{(}\AttributeTok{panel.grid =} \FunctionTok{element\_blank}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{05-ggplot2_files/figure-pdf/barplot-theme-bw-1.pdf}}

What if we wanted to see the proportion of respondents in each village
who owned a particular item? We can calculate the percent of people in
each village who own each item and then create a faceted series of bar
plots where each plot is a particular item. First we need to calculate
the percentage of people in each village who own each item:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{percent\_items }\OtherTok{\textless{}{-}}\NormalTok{ interviews\_plotting }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{group\_by}\NormalTok{(village) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{summarize}\NormalTok{(}\FunctionTok{across}\NormalTok{(bicycle}\SpecialCharTok{:}\NormalTok{no\_listed\_items, }\SpecialCharTok{\textasciitilde{}} \FunctionTok{sum}\NormalTok{(.x) }\SpecialCharTok{/} \FunctionTok{n}\NormalTok{() }\SpecialCharTok{*} \DecValTok{100}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{pivot\_longer}\NormalTok{(bicycle}\SpecialCharTok{:}\NormalTok{no\_listed\_items, }\AttributeTok{names\_to =} \StringTok{"items"}\NormalTok{, }\AttributeTok{values\_to =} \StringTok{"percent"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

To calculate this percentage data frame, we needed to use the
\texttt{across()} function within a \texttt{summarize()} operation.
Unlike the previous example with a single wall type variable, where each
response was exactly one of the types specified, people can (and do) own
more than one item. So there are multiple columns of data (one for each
item), and the percentage calculation needs to be repeated for each
column.

Combining \texttt{summarize()} with \texttt{across()} allows us to
specify first, the columns to be summarized
(\texttt{bicycle:no\_listed\_items}) and then the calculation. Because
our calculation is a bit more complex than is available in a built-in
function, we define a new formula:

\begin{itemize}
\tightlist
\item
  \texttt{\textasciitilde{}} indicates that we are defining a formula,
\item
  \texttt{sum(.x)} gives the number of people owning that item by
  counting the number of \texttt{TRUE} values (\texttt{.x} is shorthand
  for the column being operated on),
\item
  and \texttt{n()} gives the current group size.
\end{itemize}

After the \texttt{summarize()} operation, we have a table of percentages
with each item in its own column, so a \texttt{pivot\_longer()} is
required to transform the table into an easier format for plotting.
Using this data frame, we can now create a multi-paneled bar plot.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{percent\_items }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ village, }\AttributeTok{y =}\NormalTok{ percent)) }\SpecialCharTok{+}
    \FunctionTok{geom\_bar}\NormalTok{(}\AttributeTok{stat =} \StringTok{"identity"}\NormalTok{, }\AttributeTok{position =} \StringTok{"dodge"}\NormalTok{) }\SpecialCharTok{+}
    \FunctionTok{facet\_wrap}\NormalTok{(}\SpecialCharTok{\textasciitilde{}}\NormalTok{ items) }\SpecialCharTok{+}
    \FunctionTok{theme\_bw}\NormalTok{() }\SpecialCharTok{+}
    \FunctionTok{theme}\NormalTok{(}\AttributeTok{panel.grid =} \FunctionTok{element\_blank}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{05-ggplot2_files/figure-pdf/percent-items-barplot-1.pdf}}

\section{\texorpdfstring{\textbf{\texttt{ggplot2}}
themes}{ggplot2 themes}}\label{ggplot2-themes}

In addition to \texttt{theme\_bw()}, which changes the plot background
to white, \textbf{\texttt{ggplot2}} comes with several other themes
which can be useful to quickly change the look of your visualization.
The complete list of themes is available at
\url{https://ggplot2.tidyverse.org/reference/ggtheme.html}.
\texttt{theme\_minimal()} and \texttt{theme\_light()} are popular, and
\texttt{theme\_void()} can be useful as a starting point to create a new
hand-crafted theme.

The
\href{https://jrnold.github.io/ggthemes/reference/index.html}{ggthemes}
package provides a wide variety of options (including an Excel 2003
theme). The
\href{https://exts.ggplot2.tidyverse.org/}{\textbf{\texttt{ggplot2}}
extensions website} provides a list of packages that extend the
capabilities of \textbf{\texttt{ggplot2}}, including additional themes.

\section{Exercise}\label{exercise-15}

Experiment with at least two different themes. Build the previous plot
using each of those themes. Which do you like best?

\section{Customization}\label{customization}

Take a look at the
\href{https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-visualization.pdf}{\textbf{\texttt{ggplot2}}
cheat sheet}, and think of ways you could improve the plot.

Now, let's change names of axes to something more informative than
`village' and `percent' and add a title to the figure:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{percent\_items }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ village, }\AttributeTok{y =}\NormalTok{ percent)) }\SpecialCharTok{+}
    \FunctionTok{geom\_bar}\NormalTok{(}\AttributeTok{stat =} \StringTok{"identity"}\NormalTok{, }\AttributeTok{position =} \StringTok{"dodge"}\NormalTok{) }\SpecialCharTok{+}
    \FunctionTok{facet\_wrap}\NormalTok{(}\SpecialCharTok{\textasciitilde{}}\NormalTok{ items) }\SpecialCharTok{+}
    \FunctionTok{labs}\NormalTok{(}\AttributeTok{title =} \StringTok{"Percent of respondents in each village who owned each item"}\NormalTok{,}
         \AttributeTok{x =} \StringTok{"Village"}\NormalTok{,}
         \AttributeTok{y =} \StringTok{"Percent of Respondents"}\NormalTok{) }\SpecialCharTok{+}
    \FunctionTok{theme\_bw}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{05-ggplot2_files/figure-pdf/ggplot-customization-1.pdf}}

The axes have more informative names, but their readability can be
improved by increasing the font size:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{percent\_items }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ village, }\AttributeTok{y =}\NormalTok{ percent)) }\SpecialCharTok{+}
    \FunctionTok{geom\_bar}\NormalTok{(}\AttributeTok{stat =} \StringTok{"identity"}\NormalTok{, }\AttributeTok{position =} \StringTok{"dodge"}\NormalTok{) }\SpecialCharTok{+}
    \FunctionTok{facet\_wrap}\NormalTok{(}\SpecialCharTok{\textasciitilde{}}\NormalTok{ items) }\SpecialCharTok{+}
    \FunctionTok{labs}\NormalTok{(}\AttributeTok{title =} \StringTok{"Percent of respondents in each village who owned each item"}\NormalTok{,}
         \AttributeTok{x =} \StringTok{"Village"}\NormalTok{,}
         \AttributeTok{y =} \StringTok{"Percent of Respondents"}\NormalTok{) }\SpecialCharTok{+}
    \FunctionTok{theme\_bw}\NormalTok{() }\SpecialCharTok{+}
    \FunctionTok{theme}\NormalTok{(}\AttributeTok{text =} \FunctionTok{element\_text}\NormalTok{(}\AttributeTok{size =} \DecValTok{16}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{05-ggplot2_files/figure-pdf/ggplot-customization-font-size-1.pdf}}

Note that it is also possible to change the fonts of your plots. If you
are on Windows, you may have to install the
\href{https://github.com/wch/extrafont}{\textbf{\texttt{extrafont}}
package}, and follow the instructions included in the README for this
package.

After our manipulations, you may notice that the values on the x-axis
are still not properly readable. Let's change the orientation of the
labels and adjust them vertically and horizontally so they don't
overlap. You can use a 90-degree angle, or experiment to find the
appropriate angle for diagonally oriented labels. With a larger font,
the title also runs off. We can add ``\textbackslash n'' in the string
for the title to insert a new line:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{percent\_items }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ village, }\AttributeTok{y =}\NormalTok{ percent)) }\SpecialCharTok{+}
    \FunctionTok{geom\_bar}\NormalTok{(}\AttributeTok{stat =} \StringTok{"identity"}\NormalTok{, }\AttributeTok{position =} \StringTok{"dodge"}\NormalTok{) }\SpecialCharTok{+}
    \FunctionTok{facet\_wrap}\NormalTok{(}\SpecialCharTok{\textasciitilde{}}\NormalTok{ items) }\SpecialCharTok{+}
    \FunctionTok{labs}\NormalTok{(}\AttributeTok{title =} \StringTok{"Percent of respondents in each village }\SpecialCharTok{\textbackslash{}n}\StringTok{ who owned each item"}\NormalTok{,}
         \AttributeTok{x =} \StringTok{"Village"}\NormalTok{,}
         \AttributeTok{y =} \StringTok{"Percent of Respondents"}\NormalTok{) }\SpecialCharTok{+}
    \FunctionTok{theme\_bw}\NormalTok{() }\SpecialCharTok{+}
    \FunctionTok{theme}\NormalTok{(}\AttributeTok{axis.text.x =} \FunctionTok{element\_text}\NormalTok{(}\AttributeTok{colour =} \StringTok{"grey20"}\NormalTok{, }\AttributeTok{size =} \DecValTok{12}\NormalTok{, }\AttributeTok{angle =} \DecValTok{45}\NormalTok{,}
                                     \AttributeTok{hjust =} \FloatTok{0.5}\NormalTok{, }\AttributeTok{vjust =} \FloatTok{0.5}\NormalTok{),}
          \AttributeTok{axis.text.y =} \FunctionTok{element\_text}\NormalTok{(}\AttributeTok{colour =} \StringTok{"grey20"}\NormalTok{, }\AttributeTok{size =} \DecValTok{12}\NormalTok{),}
          \AttributeTok{text =} \FunctionTok{element\_text}\NormalTok{(}\AttributeTok{size =} \DecValTok{16}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{05-ggplot2_files/figure-pdf/ggplot-customization-label-orientation-1.pdf}}

If you like the changes you created better than the default theme, you
can save them as an object to be able to easily apply them to other
plots you may create. We can also add
\texttt{plot.title\ =\ element\_text(hjust\ =\ 0.5)} to centre the
title:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{grey\_theme }\OtherTok{\textless{}{-}} \FunctionTok{theme}\NormalTok{(}\AttributeTok{axis.text.x =} \FunctionTok{element\_text}\NormalTok{(}\AttributeTok{colour =} \StringTok{"grey20"}\NormalTok{, }\AttributeTok{size =} \DecValTok{12}\NormalTok{,}
                                               \AttributeTok{angle =} \DecValTok{45}\NormalTok{, }\AttributeTok{hjust =} \FloatTok{0.5}\NormalTok{,}
                                               \AttributeTok{vjust =} \FloatTok{0.5}\NormalTok{),}
                    \AttributeTok{axis.text.y =} \FunctionTok{element\_text}\NormalTok{(}\AttributeTok{colour =} \StringTok{"grey20"}\NormalTok{, }\AttributeTok{size =} \DecValTok{12}\NormalTok{),}
                    \AttributeTok{text =} \FunctionTok{element\_text}\NormalTok{(}\AttributeTok{size =} \DecValTok{16}\NormalTok{),}
                    \AttributeTok{plot.title =} \FunctionTok{element\_text}\NormalTok{(}\AttributeTok{hjust =} \FloatTok{0.5}\NormalTok{))}


\NormalTok{percent\_items }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ village, }\AttributeTok{y =}\NormalTok{ percent)) }\SpecialCharTok{+}
    \FunctionTok{geom\_bar}\NormalTok{(}\AttributeTok{stat =} \StringTok{"identity"}\NormalTok{, }\AttributeTok{position =} \StringTok{"dodge"}\NormalTok{) }\SpecialCharTok{+}
    \FunctionTok{facet\_wrap}\NormalTok{(}\SpecialCharTok{\textasciitilde{}}\NormalTok{ items) }\SpecialCharTok{+}
    \FunctionTok{labs}\NormalTok{(}\AttributeTok{title =} \StringTok{"Percent of respondents in each village }\SpecialCharTok{\textbackslash{}n}\StringTok{ who owned each item"}\NormalTok{,}
         \AttributeTok{x =} \StringTok{"Village"}\NormalTok{,}
         \AttributeTok{y =} \StringTok{"Percent of Respondents"}\NormalTok{) }\SpecialCharTok{+}
\NormalTok{    grey\_theme}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{05-ggplot2_files/figure-pdf/ggplot-custom-themes-1.pdf}}

\section{Exercise}\label{exercise-16}

With all of this information in hand, please take another five minutes
to either improve one of the plots generated in this exercise or create
a beautiful graph of your own. Use the RStudio
\href{https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-visualization.pdf}{\textbf{\texttt{ggplot2}}
cheat sheet} for inspiration. Here are some ideas:

\begin{itemize}
\tightlist
\item
  See if you can make the bars white with black outline.
\item
  Try using a different colour palette (see
  \href{https://www.cookbook-r.com/Graphs/Colors_(ggplot2)/}{http://www.cookbook-r.com/Graphs/Colors\_(ggplot2)/}).
\end{itemize}

After creating your plot, you can save it to a file in your favourite
format. The Export tab in the \textbf{Plot} pane in RStudio will save
your plots at low resolution, which will not be accepted by many
journals and will not scale well for posters.

Instead, use the \texttt{ggsave()} function, which allows you to easily
change the dimension and resolution of your plot by adjusting the
appropriate arguments (\texttt{width}, \texttt{height} and
\texttt{dpi}).

Make sure you have the \texttt{fig\_output/} folder in your working
directory.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_plot }\OtherTok{\textless{}{-}}\NormalTok{ percent\_items }\SpecialCharTok{\%\textgreater{}\%}
    \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ village, }\AttributeTok{y =}\NormalTok{ percent)) }\SpecialCharTok{+}
    \FunctionTok{geom\_bar}\NormalTok{(}\AttributeTok{stat =} \StringTok{"identity"}\NormalTok{, }\AttributeTok{position =} \StringTok{"dodge"}\NormalTok{) }\SpecialCharTok{+}
    \FunctionTok{facet\_wrap}\NormalTok{(}\SpecialCharTok{\textasciitilde{}}\NormalTok{ items) }\SpecialCharTok{+}
    \FunctionTok{labs}\NormalTok{(}\AttributeTok{title =} \StringTok{"Percent of respondents in each village }\SpecialCharTok{\textbackslash{}n}\StringTok{ who owned each item"}\NormalTok{,}
         \AttributeTok{x =} \StringTok{"Village"}\NormalTok{,}
         \AttributeTok{y =} \StringTok{"Percent of Respondents"}\NormalTok{) }\SpecialCharTok{+}
    \FunctionTok{theme\_bw}\NormalTok{() }\SpecialCharTok{+}
    \FunctionTok{theme}\NormalTok{(}\AttributeTok{axis.text.x =} \FunctionTok{element\_text}\NormalTok{(}\AttributeTok{color =} \StringTok{"grey20"}\NormalTok{, }\AttributeTok{size =} \DecValTok{12}\NormalTok{, }\AttributeTok{angle =} \DecValTok{45}\NormalTok{,}
                                     \AttributeTok{hjust =} \FloatTok{0.5}\NormalTok{, }\AttributeTok{vjust =} \FloatTok{0.5}\NormalTok{),}
          \AttributeTok{axis.text.y =} \FunctionTok{element\_text}\NormalTok{(}\AttributeTok{color =} \StringTok{"grey20"}\NormalTok{, }\AttributeTok{size =} \DecValTok{12}\NormalTok{),}
          \AttributeTok{text =} \FunctionTok{element\_text}\NormalTok{(}\AttributeTok{size =} \DecValTok{16}\NormalTok{),}
          \AttributeTok{plot.title =} \FunctionTok{element\_text}\NormalTok{(}\AttributeTok{hjust =} \FloatTok{0.5}\NormalTok{))}

\FunctionTok{ggsave}\NormalTok{(}\StringTok{"fig\_output/name\_of\_file.png"}\NormalTok{, my\_plot, }\AttributeTok{width =} \DecValTok{15}\NormalTok{, }\AttributeTok{height =} \DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Note: The parameters \texttt{width} and \texttt{height} also determine
the font size in the saved plot.

\begin{itemize}
\tightlist
\item
  \texttt{ggplot2} is a flexible and useful tool for creating plots in
  R.
\item
  The data set and coordinate system can be defined using the
  \texttt{ggplot} function.
\item
  Additional layers, including geoms, are added using the \texttt{+}
  operator.
\item
  Boxplots are useful for visualizing the distribution of a continuous
  variable.
\item
  Barplots are useful for visualizing categorical data.
\item
  Faceting allows you to generate multiple plots based on a categorical
  variable.
\end{itemize}

\bookmarksetup{startatroot}

\chapter{Summary}\label{summary}

In summary, this book has no content whatsoever.

\bookmarksetup{startatroot}

\chapter*{References}\label{references}
\addcontentsline{toc}{chapter}{References}

\markboth{References}{References}

\phantomsection\label{refs}




\end{document}
